== Intent ==

an implementation in [[Language:Haskell]] using [[Technology:DPH|Data Parallel Haskell]]

== Languages ==

* [[Language:Haskell]]

== Technologies ==

* [[Technology:GHC]]
* [[Technology:GHCi]]
* [[Technology:DPH]]

== Features ==

* [[101feature:Company]]
* [[101feature:Total]]
* [[101feature:Cut]]

== Motivation ==

We exercise data parallelism in [[Language:Haskell]] ([[Technology:DPH]]). That is, we [[101feature:Total|total]] and [[101feature:Cut|cut]] salaries in a [[101feature:Company|company]] by making use of [[Parallel Array|parallel arrays]] and other DPH-specific [[Datastructure|datastructures]].

In this context we also demonstrate some of DPH's current limitations:
* The inabilty to mix [[Vectorization|vectorized]] and non-vectorized code.
* No support for type classes.
* No vectorization support for self-definied types.
* An extra Prelude with extra primitive types.

The third limitation forces us to flatten the company to a list of salary values. Because of the fact that there is no support for the normal Prelude list ([]), we have to convert this list to a special
array type before it can be passed to data parallel total and cut functionality. (See illustration)
The cut list of salaries values has then to be "consumed" by the company in question.
These flatten/consume and conversion computations obviously take more time than we gain by switching to parallel salary functions. 
But this implementation is supposed to just demonstrate how one can use data parallism rather than being about efficient.

== Illustration ==



== Architecture ==

TBD

== Usage ==

The Haskell module ''Main'' has to be consulted with GHCi, and the
''main'' function has to be applied so that output for the test
scenarios is produced. The ''expected'' output is available through
the file ''baseline''. There is a ''Makefile'' with a target ''test''
for [[test automation]]. There is a ''clean'' target to "reset" the project.

== Contributors ==

* {{101contributor|Thomas Schmorleiz|developer}}