== Intent ==

 [[Language:Haskell|Haskell]] data/[[Language:XML|XML]] mapping with [[Technology:Pickler|picklers]]

== Languages ==

* [[Language:XML]]
* [[Language:Haskell]]

== Technologies ==

* [[Technology:HXT]]: Haskell XML Toolbox
* [[Technology:Pickler]] (comes with HXT)
* [[Technology:GHCi]]

== Features ==

* [[101feature:Company]]
* [[101feature:Total]]
* [[101feature:Cut]]
* [[101feature:Serialization]]

== Motivation ==

We exercise Haskell data/XML mapping by making use of [[Technology:HXT]]'s [[Technology:Pickler|pickler]] [[Arrow|arrows]] and functions. 

That is, we declare XmlPickler instances for companies, departments and employees and define appropriate pickler functions. 
This enables us to [[101feature:Serialization|serilize]] values of an algebraic datatype for [[101feature:Company|companies]] (much like the one in [[101implementation:haskell]]) as XML data.
We demonstrate common usage of HXT by:
* Declaring instances of the <syntaxhighlight lang="haskell" enclose="none">XMLPickler</syntaxhighlight> typeclass.
* Using predefined picklers such as <syntaxhighlight lang="haskell" enclose="none">xpPrim</syntaxhighlight> for primitive values
* Using combinators for lists (<syntaxhighlight lang="haskell" enclose="none">xpList</syntaxhighlight>), option (<syntaxhighlight lang="haskell" enclose="none">xpOption</syntaxhighlight>) and alternative (<syntaxhighlight lang="haskell" enclose="none">xpAlt</syntaxhighlight>).
* Using the wrapper pickler <syntaxhighlight lang="haskell" enclose="none">xpWrap</syntaxhighlight>.
* Using those picklers to pickle and unpickle xml documents.

== Illustration ==

=== A Pickler for Companies ===

To define a pickler for companies an instance of XMLPickler has to be declared.

<syntaxhighlight lang="haskell">
instance XmlPickler Company where
    xpickle = xpCompany
</syntaxhighlight>

For definining <syntaxhighlight lang="haskell" enclose="none">xpCompany</syntaxhighlight> we use <syntaxhighlight lang="haskell" enclose="none">xpElem</syntaxhighlight> and
<syntaxhighlight lang="haskell" enclose="none">xpWrap</syntaxhighlight>:

<syntaxhighlight lang="haskell">
xpCompany 
      = xpElem "company" $
        xpWrap ...
</syntaxhighlight>

This means, that a company should be in a tag labled "company". The content of the tag is the second argument of <syntaxhighlight lang="haskell" enclose="none">xpElem</syntaxhighlight>, defined by <syntaxhighlight lang="haskell" enclose="none">xpWrap</syntaxhighlight>.

<syntaxhighlight lang="haskell" enclose="none">xpWrap</syntaxhighlight> is of type <syntaxhighlight lang="haskell" enclose="none">(a -> b, b -> a) -> PU a -> PU b</syntaxhighlight>. 
It returns a Pickler (PU) for <syntaxhighlight lang="haskell" enclose="none">b</syntaxhighlight> and expects a pair of functions from <syntaxhighlight lang="haskell" enclose="none">a</syntaxhighlight> to <syntaxhighlight lang="haskell" enclose="none">b</syntaxhighlight> and vice versa and a Pickler for <syntaxhighlight lang="haskell"  enclose="none">a</syntaxhighlight> (<syntaxhighlight lang="haskell" enclose="none">PA a</syntaxhighlight>):

<syntaxhighlight lang="haskell">
        xpWrap ( uncurry Company
               , \c -> ( cname c
                       , depts c
                       )
                ) $
        xpPair  (xpAttr "name" xpText)
                (xpList xpickle)
</syntaxhighlight>

The first part of the first argument of the wrapping pickler is <syntaxhighlight lang="haskell" enclose="none">uncurry Company</syntaxhighlight>, which is identical to 
<syntaxhighlight lang="haskell" enclose="none">\(n,ds) -> Company n ds</syntaxhighlight>. It definies how to contruct a Company from a pair of name and departments. The 
second part of the argument defines the opposite direction.

The second argument definies the acutal pickler for the pair (this is <syntaxhighlight lang="haskell" enclose="none">PA a</syntaxhighlight> in the type signature of the wrapping pickler). 
We use the combinator <syntaxhighlight lang="haskell" enclose="none">xpPair</syntaxhighlight>. The pickler for the company name is defined by using a pickler for xml attributes and a pickler for text.
The pickler for the list of departments is defined by making use of a combinator for lists and <syntaxhighlight lang="haskell" enclose="none">xpickle</syntaxhighlight>.
Because we also declared a XMLPickler instance for departments, Haskell will choose the appropriate pickler function. 

So the pickler for companies is defined as follows:

<syntaxhighlight lang="haskell">
xpCompany :: PU Company
xpCompany 
      = xpElem "company" $
        xpWrap ( uncurry Company
               , \c -> ( cname c
                       , depts c
                       )
                ) $
        xpPair  (xpAttr "name" xpText)
                (xpList xpickle)
</syntaxhighlight>

=== Picklering a Company ===

Picklering a company is done by using [[Arrow|arrows]]:

<syntaxhighlight lang="haskell">
runX ( constA company 
       >>>
       xpickleDocument xpCompany [withIndent yes] "sampleCompanyCut.xml"
     )
</syntaxhighlight>

A lifted sample company is passed to the arrow for picklering a document. In this case the arrow function expects a pickler for companies, some writing options and a file name.

=== Unpicklering a Company ===

To unpickle a company the arrow function <syntaxhighlight lang="haskell" enclose="none">xunpickleDocument</syntaxhighlight> is used:

<syntaxhighlight lang="haskell">
cs <- runX ( xunpickleDocument xpCompany [withRemoveWS yes] "sampleCompany.xml" )
</syntaxhighlight>

<syntaxhighlight lang="haskell" enclose="none">cs</syntaxhighlight> is a list of arrow results. On success <syntaxhighlight lang="haskell" enclose="none">cs</syntaxhighlight> should be a singleton list containing the unpicklered company.

== Architecture ==

[this!!Pickler.hs] holds the pickler definitions for companies, departments and employees.

The algebraic datatype for [101feature:Company|companoies] and be found in [this!!Company.hs]. This file as well as [this!!Total.hs] and [this!!Cut] are adopted from [[101implementation:haskell]].

The ''main'' module (in [this!!Main.hs]) collects test scenarios for picklering/unpicklering, totaling and cutting companies.

== Usage ==

The Haskell module ''Main'' has to be consulted with GHCi, and the
''main'' function has to be applied so that output for the test
scenarios is produced. The ''expected'' output is available through
the file ''baseline''. There is a ''Makefile'' with a target ''test''
for [[test automation]].
Use the taget ''clean'' to "reset" the project.

== Contributors ==

* {{101contributor|Thomas Schmorleiz|developer}}