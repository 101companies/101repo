== Intent ==

 [[H/X mapping]] with  [[Technology:XML pickler]]

== Languages ==

* [[Language:XML]]
* [[Language:Haskell]]

== Technologies ==

* [[Technology:HXT]]
* [[Technology:XML pickler]] (comes with HXT)
* [[Technology:GHCi]]

== Features ==

* [[101feature:Company]]
* [[101feature:Total]]
* [[101feature:Cut]]
* [[101feature:Serialization]]

== Motivation ==

We exercise [[H/X mapping]] by making use of [[Technology:HXT]]'s  [[Technology:XML pickler]] [[Arrow|arrows]] and functions. 

That is, we declare XmlPickler instances for companies, departments and employees and define appropriate pickler functions. 
This enables us to [[101feature:Serialization|serilize]] values of an [[Algebraic datatype|algebraic datatype]] for [[101feature:Company|companies]] as [[Language:XML|XML]] data.
We demonstrate common usage of HXT by:
* Declaring instances of the <syntaxhighlight lang="haskell" enclose="none">XMLPickler</syntaxhighlight> typeclass.
* Using predefined picklers such as <syntaxhighlight lang="haskell" enclose="none">xpPrim</syntaxhighlight> for primitive values
* Using combinators for lists (<syntaxhighlight lang="haskell" enclose="none">xpList</syntaxhighlight>), option (<syntaxhighlight lang="haskell" enclose="none">xpOption</syntaxhighlight>) and alternative (<syntaxhighlight lang="haskell" enclose="none">xpAlt</syntaxhighlight>).
* Using the wrapper pickler <syntaxhighlight lang="haskell" enclose="none">xpWrap</syntaxhighlight>.
* Using those picklers to pickle (say serialize) and unpickle (say deserialize) xml documents.

== Illustration ==

=== A Pickler for Companies ===

To define a pickler for companies we declare an instance of <syntaxhighlight lang="haskell" enclose="none">XMLPickler</syntaxhighlight> in the ''Pickler'' module (hosted by [this!!Pickler.hs]:

<syntaxhighlight lang="haskell">
instance XmlPickler Company where
    xpickle = xpCompany
</syntaxhighlight>

The acutal pickler function XMLPickler <syntaxhighlight lang="haskell" enclose="none">xpCompany</syntaxhighlight> is defined as follows:

<syntaxhighlight lang="haskell" line>
xpCompany :: PU Company
xpCompany 
      = xpElem "company" $
        xpWrap ( uncurry Company
               , \c -> ( cname c
                       , depts c
                       )
                ) $
        xpPair  (xpAttr "name" xpText)
                (xpList xpickle)
</syntaxhighlight>

For implementing <syntaxhighlight lang="haskell" enclose="none">xpCompany</syntaxhighlight> we use <syntaxhighlight lang="haskell" enclose="none">xpElem</syntaxhighlight> in line 3.
We define that a company, represented in XML, should be inside a XML-tag labled "company". The content of the tag is the second argument of <syntaxhighlight lang="haskell" enclose="none">xpElem</syntaxhighlight>, defined by <syntaxhighlight lang="haskell" enclose="none">xpWrap</syntaxhighlight>.

<syntaxhighlight lang="haskell" enclose="none">xpWrap</syntaxhighlight> is of type <syntaxhighlight lang="haskell" enclose="none">(a -> b, b -> a) -> PU a -> PU b</syntaxhighlight>. 
It returns a Pickler (PU) for <syntaxhighlight lang="haskell" enclose="none">b</syntaxhighlight> and expects a pair of functions from <syntaxhighlight lang="haskell" enclose="none">a</syntaxhighlight> to <syntaxhighlight lang="haskell" enclose="none">b</syntaxhighlight> and vice versa and a Pickler for <syntaxhighlight lang="haskell"  enclose="none">a</syntaxhighlight> (<syntaxhighlight lang="haskell" enclose="none">PA a</syntaxhighlight>).

In lines 4-8 the first part of the firt argument of the wrapping pickler is <syntaxhighlight lang="haskell" enclose="none">uncurry Company</syntaxhighlight>, which is identical to 
<syntaxhighlight lang="haskell" enclose="none">\(n,ds) -> Company n ds</syntaxhighlight>. It definies how to contruct a <syntaxhighlight lang="haskell" enclose="none">Company</syntaxhighlight> value from a pair of name and departments. The second part of the pair defines the opposite direction: How to disassemble a company into it's components.

The second argument of <syntaxhighlight lang="haskell" enclose="none">xpWrap</syntaxhighlight> in lines 9-10 definies the acutal pickler for the (name, departments) pair (this is <syntaxhighlight lang="haskell" enclose="none">PA a</syntaxhighlight> in the type signature of the wrapping pickler). 
We use the combinator for pairs <syntaxhighlight lang="haskell" enclose="none">xpPair :: PU a -> PU b -> PU (a, b)</syntaxhighlight>. The pickler for the company name is defined by using a pickler for xml attributes and a pickler for text. That is, the company name should be an attribute of the "company" tag.
The pickler for the list of departments is defined by making use of a combinator for lists and <syntaxhighlight lang="haskell" enclose="none">xpickle</syntaxhighlight>.
Because of type inference and because we also declared a XMLPickler instance for departments, Haskell will choose the appropriate pickler function.  

=== Picklering a Company ===

Picklering a company is realized by using arrows:

<syntaxhighlight lang="haskell">
runX ( constA company 
       >>>
       xpickleDocument xpCompany [withIndent yes] "sampleCompanyCut.xml"
     )
</syntaxhighlight>

A lifted sample company is passed to the arrow for picklering a document. In this case the arrow function expects a pickler for companies, some writing options and a file name.

=== Unpicklering a Company ===

To unpickle a company the arrow function <syntaxhighlight lang="haskell" enclose="none">xunpickleDocument</syntaxhighlight> is used:

<syntaxhighlight lang="haskell">
[company1] <- runX ( xunpickleDocument xpCompany [withRemoveWS yes] "sampleCompany.xml" )
</syntaxhighlight>

<syntaxhighlight lang="haskell" enclose="none">runX</syntaxhighlight> returns a list of arrow results, which we except to be a singleton list. On success <syntaxhighlight lang="haskell" enclose="none">company1</syntaxhighlight> should hold the unpicklered company.

== Architecture ==

[this!!Pickler.hs] holds the pickler definitions for companies, departments and employees. The algebraic datatype for companies can be found in [this!!Company.hs]. This file as well as [this!!Total.hs] and [this!!Cut] are adopted from [[101implementation:haskell]].The ''main'' module (in [this!!Main.hs]) collects test scenarios for picklering/unpicklering, totaling and cutting companies.

== Usage ==

* The Haskell module ''Main'' (hosted by [this!!Main.hs]) has to be loaded into GHCi. 
* The <syntaxhighlight lang="haskell" enclose="none">main</syntaxhighlight> function has to be applied.
* The output should be equal to the content of the file [this!!baseline].

One can also use the [this!!Makefile] with a target ''test'' for [[test automation]].

* Use the taget ''clean'' to "reset" the project.

== Contributors ==

* {{101contributor|Thomas Schmorleiz|developer}}