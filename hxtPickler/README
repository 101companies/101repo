== Intent ==

 [[H/X mapping]] with  [[Technology:XML pickler|XML picklers]]

== Languages ==

* [[Language:XML]]
* [[Language:Haskell]]

== Technologies ==

* [[Technology:HXT]]
* [[Technology:XML pickler]] (comes with HXT)
* [[Technology:GHCi]]

== Features ==

* [[101feature:Company]]
* [[101feature:Total]]
* [[101feature:Cut]]
* [[101feature:Serialization]]
* [[101feature:Mapping]]

== Motivation ==

We exercise [[101feature:Mapping|mapping]] from Haskell to XML data by making use of [[Technology:HXT]]'s  [[Technology:XML pickler]] [[Arrow|arrows]] and functions. 
That is, we declare <syntaxhighlight lang="haskell" enclose="none">XMLPickler</syntaxhighlight> instances for companies, departments and employees and define appropriate pickler functions. In this context we illustrate predefined picklers and pickler combinators. 
This enables us to [[101feature:Serialization|serialize]] values of [[Algebraic datatype|algebraic datatypes]] for [[101feature:Company|companies]] as [[Language:XML|XML]] data.

== Illustration ==

=== A Pickler for Companies ===

To define a pickler for companies we declare an instance of <syntaxhighlight lang="haskell" enclose="none">XMLPickler</syntaxhighlight>:

<syntaxhighlight lang="haskell" source="hxtPickler/Pickler.hs">
instance XmlPickler Company where
    xpickle = xpCompany
</syntaxhighlight>

The pickler function <syntaxhighlight lang="haskell" enclose="none">xpCompany</syntaxhighlight> is defined as follows:

<syntaxhighlight lang="haskell" source="hxtPickler/Pickler.hs" line>
xpCompany :: PU Company
xpCompany 
      = xpElem "company" $
        xpWrap ( uncurry Company
               , \c -> ( cname c
                       , depts c
                       )
                ) $
        xpPair  (xpAttr "name" xpText)
                (xpList xpickle)
</syntaxhighlight>

For implementing <syntaxhighlight lang="haskell" enclose="none">xpCompany</syntaxhighlight> we use <syntaxhighlight lang="haskell" enclose="none">xpElem</syntaxhighlight> in line 3.
We define that a company, represented in XML, should be inside a XML-tag labeled "company". The content of the tag is the second argument of <syntaxhighlight lang="haskell" enclose="none">xpElem</syntaxhighlight>, defined by <syntaxhighlight lang="haskell" enclose="none">xpWrap</syntaxhighlight>.

<syntaxhighlight lang="haskell" enclose="none">xpWrap</syntaxhighlight> is of type <syntaxhighlight lang="haskell" enclose="none">(a -> b, b -> a) -> PU a -> PU b</syntaxhighlight>. 
It returns a Pickler (PU) for <syntaxhighlight lang="haskell" enclose="none">b</syntaxhighlight> and expects a pair of functions from <syntaxhighlight lang="haskell" enclose="none">a</syntaxhighlight> to <syntaxhighlight lang="haskell" enclose="none">b</syntaxhighlight> and vice versa and a Pickler for <syntaxhighlight lang="haskell"  enclose="none">a</syntaxhighlight> (<syntaxhighlight lang="haskell" enclose="none">PA a</syntaxhighlight>).

In lines 4-8 the first part of the first argument of the wrapping pickler is <syntaxhighlight lang="haskell" enclose="none">uncurry Company</syntaxhighlight>, which is identical to 
<syntaxhighlight lang="haskell" enclose="none">\(n,ds) -> Company n ds</syntaxhighlight>. It defines how to construct a <syntaxhighlight lang="haskell" enclose="none">Company</syntaxhighlight> value from a pair of name and departments. The second part of the pair defines the opposite direction: How to disassemble a company into its components.

The second argument of <syntaxhighlight lang="haskell" enclose="none">xpWrap</syntaxhighlight> in lines 9-10 defines the actual pickler for the (name, departments) pair (this is <syntaxhighlight lang="haskell" enclose="none">PA a</syntaxhighlight> in the type signature of the wrapping pickler). 
We use the combinator for pairs <syntaxhighlight lang="haskell" enclose="none">xpPair :: PU a -> PU b -> PU (a, b)</syntaxhighlight>. The pickler for the company name is defined by using a pickler for XML attributes and a pickler for text. That is, the company name should be an attribute of the "company" tag.
The pickler for the list of departments is defined by making use of a combinator for lists and <syntaxhighlight lang="haskell" enclose="none">xpickle</syntaxhighlight>.
Because of type inference and because we also declared a XMLPickler instance for departments, Haskell will choose the appropriate pickler function for departments.

=== Pickling a Company ===

Pickling a company is realized by using arrows:

<syntaxhighlight lang="haskell" source="hxtPickler/Main.hs">
runX ( constA company 
       >>>
       xpickleDocument xpCompany [withIndent yes] $ 
       "sampleCompanyCut.xml"
     )
</syntaxhighlight>

A lifted sample company is passed to the arrow for pickling a document. In this case <syntaxhighlight lang="haskell" enclose="none">xpickleDocument</syntaxhighlight> expects a pickler for companies, some writing options and a file name.

=== Unpickling a Company ===

To unpickle a company the arrow function <syntaxhighlight lang="haskell" enclose="none">xunpickleDocument</syntaxhighlight> is used:

<syntaxhighlight lang="haskell" source="hxtPickler/Main.hs">
[company1] <- runX ( xunpickleDocument xpCompany $ 
                     [withRemoveWS yes] $ 
                     "sampleCompany.xml" )
</syntaxhighlight>

<syntaxhighlight lang="haskell" enclose="none">runX</syntaxhighlight> returns a list of arrow results, which we except to be a singleton list. On success <syntaxhighlight lang="haskell" enclose="none">company1</syntaxhighlight> should hold the unpicklered company.

== Architecture ==

[this!!Pickler.hs] holds the pickler definitions for companies, departments and employees. The algebraic datatype for companies can be found in [this!!Company.hs].[this!!Total.hs] and [this!!Cut] provide totaling and cutting functionality.[this!!Main.hs] collects test scenarios for pickling/unpickling, totaling and cutting companies.

== Usage ==

* [this!!Main.hs] has to be loaded into GHCi. 
* The <syntaxhighlight lang="haskell" enclose="none">main</syntaxhighlight> function has to be applied.
* The output should be equal to the content of the file [this!!baseline].
One can also use the [this!!Makefile] with a target ''test'' for [[test automation]].

== Contributors ==

* {{101contributor|Thomas Schmorleiz|developer}}