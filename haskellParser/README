== Intent ==

parsing textual syntax with [[Parsec]] in [[Language:Haskell]]

== Languages ==

* [[Language:Haskell 98]]

== Technologies ==

* [[Technology:GHCi]]

== Features ==

* [[101feature:Company]]
* [[101feature:Total]]
* [[101feature:Cut]]
* [[101feature:Mentoring]]
* [[101feature:Serialization]]
* [[101feature:Parsing]]

== Motivation ==

We make use of [[Language:Haskell]]'s [[Parsec]] [[Parser|parser]] combinator library to parse concrete textual syntax for [[101feature:Company|companies]].
We combine smaller parsers, say for salaries, to larger parsers, say for employees, to build a parser for companies.
In terms of parsing we exercice:

* Sequence
* Alternative
* Option

This implementation also demonstrates [[Functor|functors]] and functor combinators, provided by the ''Control.Applicative'' module.
The modules holding the [[Algebraic datatype|algebraic datatype]] to represent companies and the functionality to [[101feature:Total|total]] and [[101feature:Cut|cut]]
companies are identical to the modules in the basic [[101implementation:haskell|haskell]] implementation.

== Architecture ==

[this!!Parser.hs] provides the Parsec-based parser. [this!!Company.hs] holds the algebraic datatype for companies, 
while [this!!Total.hs] and [this!!Cut.hs] provide functionality to total and cut companies. [this!!SampleCompany] holds a sample company used 
to be compared to a parsed sample company (in [this!!sample.Company]). The Main module ([this!!Main.hs]) collects test scenarios.

== Illustration ==

We define a type alias for all of our parser:

<syntaxhighlight lang="haskell" line>
type P = Parsec String ()
</syntaxhighlight>

That is, we are dealing with parsers of stream type <syntaxhighlight lang="haskell" enclose="none">String</syntaxhighlight> and state type <syntaxhighlight lang="haskell" enclose="none">()</syntaxhighlight> (no state).

=== Parsing a department ===

<syntaxhighlight lang="haskell" line>
pDepartment :: P Department
pDepartment = Department
  <$  pString "department" <*> pLit 
  <*  pString "{" <*> pEmployee "manager"
  <*> many pSubUnit <* pString "}"
</syntaxhighlight>

To compose a department parser we make use of the <syntaxhighlight lang="haskell" enclose="none">(<$) :: Functor f => a -> f b -> f a </syntaxhighlight> operator. That is, we pass the department contructor  <syntaxhighlight lang="haskell" enclose="none">Department</syntaxhighlight> and parsers for all contructor parameters (name, manager, list of subunits) to receive a parser for departments.





== Usage ==

The Haskell module ''Main'' has to be consulted with GHCi, and the
''main'' function has to be applied so that output for the test
scenarios is produced. The ''expected'' output is available through
the file ''baseline''. There is a ''Makefile'' with a target ''test''
for [[test automation]].

== Contributors ==

* {{101contributor|Martijn van Steenbergen|developer}}
* {{101contributor|Thomas Schmorleiz|developer}}
* {{101contributor|Ralf LÃ¤mmel|developer}}