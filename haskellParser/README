== Intent ==

parsing textual syntax with [[Parsec]] in [[Language:Haskell]]

== Languages ==

* [[Language:Haskell 98]]

== Technologies ==

* [[Technology:GHCi]]

== Features ==

* [[101feature:Company]]
* [[101feature:Total]]
* [[101feature:Cut]]
* [[101feature:Mentoring]]
* [[101feature:Serialization]]
* [[101feature:Parsing]]

== Motivation ==

We make use of [[Language:Haskell]]'s [[Parsec]] [[Parser|parser]] combinator library to parse concrete textual syntax for [[101feature:Company|companies]].
We combine smaller parsers, say for salaries, to larger parsers, say for employees, to build a parser for companies.
In terms of parsing we exercice:

* Sequence
* Alternative
* Option

This implementation also demonstrates [[Functor|functors]] and functor combinators, provided by the ''Control.Applicative'' module.

== Illustration ==

=== Parser type ===

We define a type alias of all parsers that are definied in this implementation:

<syntaxhighlight lang="haskell" line>
type P = Parsec String ()
</syntaxhighlight>

That is, we are dealing with parsers of stream type <syntaxhighlight lang="haskell" enclose="none">String</syntaxhighlight> and state type <syntaxhighlight lang="haskell" enclose="none">()</syntaxhighlight> (no state).

=== Primitive parsers ===

In order to build the company parser we first need some primitive parsers.

For parsing a given <syntaxhighlight lang="haskell" enclose="none">String</syntaxhighlight> value we define:

<syntaxhighlight lang="haskell" line>
pString :: String -> P String
pString s = string s <* spaces
</syntaxhighlight>

This parser also comsumes trailing spaces.

We also need a parser for literals. <syntaxhighlight lang="haskell" enclose="none">pLit</syntaxhighlight> parses a quoted string:

<syntaxhighlight lang="haskell" line>
pLit :: P String
pLit = string "\"" *> many (noneOf "\"") <* string "\"" <* spaces
</syntaxhighlight>

=== Parsing a department ===

<syntaxhighlight lang="haskell" line>
pDepartment :: P Department
pDepartment = Department
  <$  pString "department" <*> pLit 
  <*  pString "{" <*> pEmployee "manager"
  <*> many pSubUnit <* pString "}"
</syntaxhighlight>

We make use of the <syntaxhighlight lang="haskell" enclose="none">(<$) :: Functor f => a -> f b -> f a </syntaxhighlight> operator. That is, we pass the department contructor <syntaxhighlight lang="haskell" enclose="none">Department</syntaxhighlight> and a parser for all contructor parameters (for name, manager and for the list of subunits) to receive a parser for departments. 
In line 3 we parse the keyword for department declaration "department". After that we parse the department name, followed by an opening curly bracket in line 4. Then we parse the department's manager using the employee parser <syntaxhighlight lang="haskell" enclose="none">pEmployee</syntaxhighlight>, which should use "manager" as the declaration keyword. After that we use <syntaxhighlight lang="haskell" enclose="none">many :: f a -> f [a]</syntaxhighlight> in line 5 to parse the list of subunits using <syntaxhighlight lang="haskell" enclose="none">pSubUnit</syntaxhighlight> as the parser for each subunits. At the end of a department declaration we expect a closing curly bracket.

=== Running the Parser ===

Running the company parser is realized by making use of <syntaxhighlight lang="haskell" enclose="none">runP :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a</syntaxhighlight>.
We are dealing with parsers of type <syntaxhighlight lang="haskell" enclose="none">Parsec String ()</syntaxhighlight>, which parse values of type <syntaxhighlight lang="haskell" enclose="none">Company</syntaxhighlight>.Therefore in this example the type signature for <syntaxhighlight lang="haskell" enclose="none">runP</syntaxhighlight> simplifies to <syntaxhighlight lang="haskell" enclose="none">Parsec String () Company -> () -> SourceName -> String -> Either ParseError a</syntaxhighlight>. When we choose <syntaxhighlight lang="haskell" enclose="none">"input"</syntaxhighlight> as the source name we can define a function to run the company parser:

<syntaxhighlight lang="haskell" line>
parseCompany :: String -> Either ParseError Company
parseCompany = runP (spaces *> pCompany <* eof) () "input"
</syntaxhighlight>

We added a parser for possible leading spaces and a parser for the EOF-symbol.

=== Executing the Parser ===

In the ''Main'' module (in [this!!Main.hs]) we execute the company parser:

<syntaxhighlight lang="haskell" line>
parsedCompany <- liftM parseCompany $ readFile "sample.Company"
</syntaxhighlight>

The variable either holds a parse error or a company. 
We define a print-function:

<syntaxhighlight lang="haskell" line>
rightApplyPrint :: Show a => Either ParseError Company -> (Company -> a) -> IO ()
rightApplyPrint (Right c) f = print $ f c
rightApplyPrint (Left e) _ = print e
</syntaxhighlight>

In case parsing was successful this function applies a given function to the company and prints the result. In case of a parse error it prints the error message.

We can use this function to print the total salary in case of parsing success:

<syntaxhighlight lang="haskell" line>
rightApplyPrint parsedCompany total
</syntaxhighlight>

== Architecture ==

[this!!Parser.hs] provides the Parsec-based parser. [this!!Company.hs] holds the algebraic datatype for companies, 
while [this!!Total.hs] and [this!!Cut.hs] provide functionality to total and cut companies. [this!!SampleCompany] holds a sample company used 
to be compared to a parsed sample company (in [this!!sample.Company]). The Main module ([this!!Main.hs]) collects test scenarios.

== Usage ==

The Haskell module ''Main'' has to be consulted with GHCi, and the
''main'' function has to be applied so that output for the test
scenarios is produced. The ''expected'' output is available through
the file ''baseline''. There is a ''Makefile'' with a target ''test''
for [[test automation]].

== Contributors ==

* {{101contributor|Martijn van Steenbergen|developer}}
* {{101contributor|Thomas Schmorleiz|developer}}
* {{101contributor|Ralf LÃ¤mmel|developer}}