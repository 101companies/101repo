== Intent ==

database programming with [[Technology:HaskellDB]]

== Languages ==

* [[Language:Haskell 98]]
* [[Language:SQL]]

== Technologies ==

* [[Technology:HaskellDB]]
* [[Technology:ODBC]]
* [[Technology:HDBC]]
* [[Technology:DBDirect]]
* [[Technology:MySql]]
* [[Technology:GHCi]]      

== Features ==

* [[101feature:Company]]
* [[101feature:Total]]
* [[101feature:Cut]]

== Motivation ==

We make use of [[Technology:HaskellDB|HaskellDB]] to express [[Database|database]] [[Query|queries]] as [[Language:Haskell]] functions rather than [[Language:SQL]]-statements. That is, we use the rich [[Combinator Library|combinator library]] of HaskellDB to express [[101feature:Total|totaling]] and [[101feature:Cut|cutting]] statements based on [[Rational algebra|rational algebra]].  We demonstrate:

* Projection (HaskellDB' <syntaxhighlight lang="haskell" enclose="none">project</syntaxhighlight>)
* Selection (HaskellDB' <syntaxhighlight lang="haskell" enclose="none">restrict</syntaxhighlight>)
* Aggregation (Here HaskellDB' <syntaxhighlight lang="haskell" enclose="none">_sum</syntaxhighlight>)
* Renaming (HaskellDB' <syntaxhighlight lang="haskell" enclose="none"><<</syntaxhighlight>)

We connect to the underlining [[Technology:MySql]] database through a HaskellDB-[[Technology:HDBC]]-[[Technology:ODBC]] backend. We show the common approach of seperating query/statement definition from the actual [[Database implementation|database implementation]]-dependent query/statement execution. That is, the queries and statements themselfs are database implementation-independent (see the illustration section for details).

This implementation also demonstrates the use of [[Technology:DBDirect]]. We use this [[Tool|tool]] to generate the modules describing the database. The modules are the basis for quering the rational data.

== Illustration ==

=== Connecting to the database ===

The ''MyConnection'' module (hold by [this!!MyConnection.hs]) provides connection functionality:

<syntaxhighlight lang="haskell">
withDB :: (Database -> IO a) -> IO a
withDB = connect driver conf
  where           
    conf = [ ("Driver","MySQL ODBC 5.1 Driver")
           , ("Port","3306")
           , ("Server", "localhost")
           , ("User", "root")
           , ("Database", "101companies") ]
</syntaxhighlight>

We use <syntaxhighlight lang="haskell" enclose="none">connect</syntaxhighlight> and <syntaxhighlight lang="haskell" enclose="none">driver</syntaxhighlight>, which are both provided by the HDBC-ODBC backend.
By looking at the return type of the function one can see that any database function of type <syntaxhighlight lang="haskell" enclose="none">Database -> IO a</syntaxhighlight> can be applied to <syntaxhighlight lang="haskell" enclose="none">withDB</syntaxhighlight> resulting in the specified IO action and possibly a result of type <syntaxhighlight lang="haskell" enclose="none">a</syntaxhighlight>. We thereby achive complete independence from the underling database implementation. One just has to use <syntaxhighlight lang="haskell" enclose="none">withDB</syntaxhighlight> to execute queries/statements.

=== HaskellDB ===

We use HaskellDB to generate a module describing the database:

<syntaxhighlight lang="make">
dbdirect-hdbc-odbc "DBDesc" "DBDesc" "Driver=MySQL ODBC 5.1 Driver;Port=3306;Server=localhost;User=root;Database=101companies"
</syntaxhighlight>

This command generates a module describing the database by '''naming''' tables and fields. Compiling this module with GHC creates one module per table, each module holding actual '''variables''' for tables and fields. These variables are the basis for the following query.

=== Totaling ===

A function defining a query to total all salaries can be found in the ''Total'' module (in [this!!Total.hs]).We import the description modules for the companies and employees tables:

<syntaxhighlight lang="haskell">
import qualified DBDesc.Employee as E
import qualified DBDesc.Company as C
</syntaxhighlight>

Because we want to store the sum of all salaries in a special field, we need to define it:

<syntaxhighlight lang="haskell">
data Ttl = Ttl

instance FieldTag Ttl where fieldName _ = "ttl"
  
ttl :: Attr Ttl Double
ttl = mkAttr Ttl  
</syntaxhighlight>

This basically specifies what the name of the field should be and which type the value has, which the field is holding.

The acutal total query looks like this:

<syntaxhighlight lang="haskell">
total :: String -> Query (Rel (RecCons Ttl (Expr Double) RecNil))
total cname = do 
  es <- table E.employee
  cs <- table C.company
  restrict (fromNull (constant 0) (cs!C.xid) .==. es!E.cid 
            .&&. cs!C.name .==. constant cname)
  project (ttl << _sum (es!E.salary))
</syntaxhighlight>

We are working in the <syntaxhighlight lang="haskell" enclose="none">Query</syntaxhighlight> monad. The <syntaxhighlight lang="haskell" enclose="none">table</syntaxhighlight> functions return all records in the given table. Using two tables basically gives us the rational cross product of those tables. We use HaskellDB's selection function <syntaxhighlight lang="haskell" enclose="none">restrict</syntaxhighlight> to select only those rows in which the company-id of the employee is equal to the company with has the given name <syntaxhighlight lang="haskell" enclose="none">cname</syntaxhighlight>. Inside <syntaxhighlight lang="haskell" enclose="none">project</syntaxhighlight> we only select the salary column and then use the aggregation function <syntaxhighlight lang="haskell" enclose="none">_sum</syntaxhighlight> to total all salaries. After that we put the value in the above definied field. 

=== Executing the query ===

We use <syntaxhighlight lang="haskell" enclose="none">query</syntaxhighlight> and <syntaxhighlight lang="haskell" enclose="none">withDB</syntaxhighlight> to execute the totaling query:

<syntaxhighlight lang="haskell">
[res] <- withDB $ (\db -> query db (total "meganalysis"))
</syntaxhighlight>

This gives us a list (which we expect to be a singleton list) of records. We can now access the <syntaxhighlight lang="haskell" enclose="none">ttl</syntaxhighlight> field of <syntaxhighlight lang="haskell" enclose="none">res</syntaxhighlight> to access the acutal total value and print it:

<syntaxhighlight lang="haskell">
print $ res!ttl
</syntaxhighlight>

== Architecture ==

TBC

== Usage ==

TBD

== Contributors ==

* {{101contributor|Thomas Schmorleiz|developer}}