== Intent ==

typesave [[:Category:Database_management_system|database]] programming with [[Technology:HDBC]]

== Languages ==

* [[Language:Haskell]]
* [[Language:SQL]]

== Technologies ==

* [[Technology:HaskellDB]]
* [[Technology:ODBC]]
* [[Technology:HDBC]]
* [[Technology:DBDirect]]
* [[Technology:MySQL]]
* [[Technology:GHCi]]      

== Features ==

* [[101feature:Company]]
* [[101feature:Total]]
* [[101feature:Cut]]

== Motivation ==

We make use of [[Technology:HaskellDB|HaskellDB]] to express [[:Category:Database_management_system|database]] [[Query|queries]] as [[Language:Haskell]] functions rather than [[Language:SQL]]-statements. That is, we use the rich combinator [[:Category:Library|library]] of HaskellDB to express [[101feature:Total|totaling]] and [[101feature:Cut|cutting]] statements based on [[Rational algebra|rational algebra]].  We demonstrate:
* Projection (HaskellDB's <syntaxhighlight lang="haskell" enclose="none">project</syntaxhighlight>)
* Selection (HaskellDB's <syntaxhighlight lang="haskell" enclose="none">restrict</syntaxhighlight>)
* Aggregation (Here HaskellDB's <syntaxhighlight lang="haskell" enclose="none">_sum</syntaxhighlight>)
* Renaming (HaskellDB's <syntaxhighlight lang="haskell" enclose="none"><<</syntaxhighlight>)
We connect to the underlining [[Technology:MySQL]] database through a HaskellDB-[[Technology:HDBC]]-[[Technology:ODBC]] backend. We show the common approach of seperating query/statement definition from the actual [[:Category:Database management system|database implementation]]-dependent query/statement execution <cite>bringert2004student</cite>. That is, the queries and statements themselfs are database implementation-independent (see the illustration section for details).

This implementation also demonstrates the use of [[Technology:DBDirect]]. We use this tool to generate the modules describing the database. The modules are the basis for quering the rational data.

== Illustration ==

=== Connecting to the database ===

The ''MyConnection'' module (hold by [this!!MyConnection.hs]) provides connection functionality:

<syntaxhighlight lang="haskell">
withDB :: (Database -> IO a) -> IO a
withDB = connect driver conf
  where           
    conf = [ ("Driver","MySQL ODBC 5.1 Driver")
           , ("Port","3306")
           , ("Server", "localhost")
           , ("User", "root")
           , ("Database", "101companies") ]
</syntaxhighlight>

We use <syntaxhighlight lang="haskell" enclose="none">connect</syntaxhighlight> and <syntaxhighlight lang="haskell" enclose="none">driver</syntaxhighlight>, which are both provided by the HDBC-ODBC backend.
By looking at the return type of the function one can see that any database function of type <syntaxhighlight lang="haskell" enclose="none">Database -> IO a</syntaxhighlight> can be applied to <syntaxhighlight lang="haskell" enclose="none">withDB</syntaxhighlight> resulting in the specified IO action and possibly a result of type <syntaxhighlight lang="haskell" enclose="none">a</syntaxhighlight>. By encapsulating the connection process like this we achive complete independence from the underling database implementation for all queries and statements. 

=== DBDirect ===

We use DBDirect to generate a module describing the database:

<syntaxhighlight lang="make">
dbdirect-hdbc-odbc "DBDesc" "DBDesc" "Driver=MySQL ODBC 5.1 Driver;Port=3306;Server=localhost;User=root;Database=101companies"
</syntaxhighlight>

This command generates a module describing the database by '''naming''' tables and fields. Compiling this module with GHC creates one module per table, each module holding actual '''variables''' for tables and fields. These variables are the basis for the following query:

=== Totaling ===

A function defining a query to total all salaries of a given company (specified by name) can be found in the ''Total'' module (in [this!!Total.hs]). We import the description modules for the companies and employees tables:

<syntaxhighlight lang="haskell">
import qualified DBDesc.Employee as E
import qualified DBDesc.Company as C
</syntaxhighlight>

Because we want to store the sum of all salaries in a special field, we need to define one:

<syntaxhighlight lang="haskell">
data Ttl = Ttl

instance FieldTag Ttl where fieldName _ = "ttl"
  
ttl :: Attr Ttl Double
ttl = mkAttr Ttl  
</syntaxhighlight>

We declare <syntaxhighlight lang="haskell" enclose="none">Ttl</syntaxhighlight> to be an instance of the <syntaxhighlight lang="haskell" enclose="none">Fieldtag</syntaxhighlight> class by specifying what the name of the field should be. We use this field and HaskellDB's <syntaxhighlight lang="haskell" enclose="none">mkAttr</syntaxhighlight> to define <syntaxhighlight lang="haskell" enclose="none">ttl</syntaxhighlight>, a attribute for holding a <syntaxhighlight lang="haskell" enclose="none">Double</syntaxhighlight> value. We will use this attribute to access the field.

The acutal total query looks like this:

<syntaxhighlight lang="haskell">
total :: String -> Query (Rel (RecCons Ttl (Expr Double) RecNil))
total cname = do 
  es <- table E.employee
  cs <- table C.company
  restrict (fromNull (constant 0) (cs!C.xid) .==. es!E.cid 
            .&&. cs!C.name .==. constant cname)
  project (ttl << _sum (es!E.salary))
</syntaxhighlight>

We are working in the <syntaxhighlight lang="haskell" enclose="none">Query</syntaxhighlight> monad. The <syntaxhighlight lang="haskell" enclose="none">table</syntaxhighlight> functions return all records in the given table. Using two tables basically gives us the rational cross product of those tables. We use HaskellDB's selection function <syntaxhighlight lang="haskell" enclose="none">restrict</syntaxhighlight> to select only those rows in which the company-id of the employee is equal to the company which has the given name <syntaxhighlight lang="haskell" enclose="none">cname</syntaxhighlight>. By making use of <syntaxhighlight lang="haskell" enclose="none">project</syntaxhighlight> we only select the salary column and then use the aggregation function <syntaxhighlight lang="haskell" enclose="none">_sum</syntaxhighlight> to total all salaries. After that we put the total value in the above definied field. 

=== Executing the query ===

We use <syntaxhighlight lang="haskell" enclose="none">query</syntaxhighlight> and <syntaxhighlight lang="haskell" enclose="none">withDB</syntaxhighlight> to execute the totaling query:

<syntaxhighlight lang="haskell">
[res] <- withDB $ (\db -> query db (total "meganalysis"))
</syntaxhighlight>

This gives us a list (which we expect to be a singleton list) of records. We can now access the <syntaxhighlight lang="haskell" enclose="none">ttl</syntaxhighlight> attribute of the record <syntaxhighlight lang="haskell" enclose="none">res</syntaxhighlight> by using the <syntaxhighlight lang="haskell" enclose="none">(!)</syntaxhighlight>-operator. After that we print the total value:

<syntaxhighlight lang="haskell">
print $ res!ttl
</syntaxhighlight>

== Architecture ==

We provide sql-scripts to create (see [this!!Company.sql]) company tables and populate (see [this!!Meganalysis.sql]) these tables. [this!!Total.hs] and [this!!Cut.hs] provide totaling and cutting functionality using HaskellDB's rational algebra library. The ''MyConnection'' module in [this!!MyConnection.hs] encapsulate the process of connecting to the MySql database. The ''Main'' module (in [this!!Main.hs]) collects test scenarios for totaling and cutting.

== Usage ==

=== Setup ===

* Follow the steps of setting up the database as described in [[101implementation:hdbc]]

=== Generating the database description ===

* Execute the following command in the implementation folder: <syntaxhighlight lang="make" enclose="none">dbdirect-hdbc-odbc "DBDesc" "DBDesc" "Driver=MySQL ODBC 5.1 Driver;Port=3306;Server=localhost;User=root;Database=101companies"</syntaxhighlight>
* Compile the ''DBDesc'' module using GHC: <syntaxhighlight lang="make" enclose="none">ghc DBDesc</syntaxhighlight>

=== Testing ===

* The Haskell module ''Main'' (hosted by [this!!Main.hs]) has to be loaded into GHCi. 
* The <syntaxhighlight lang="haskell" enclose="none">main</syntaxhighlight> function has to be applied.
* The output should be equal to the content of the file [this!!baseline].
One can also use the [this!!Makefile] with a target ''test'' for [[test automation]].
* Use the taget ''clean'' to "reset" the project.

== Contributors ==

* {{101contributor|Thomas Schmorleiz|developer}}

<biblio>
#bringert2004student bibtex=@inproceedings{bringert2004student,
  title={Student paper: HaskellDB improved},
  author={Bringert, B. and HÃ¶ckersten, A. and Andersson, C. and Andersson, M. and Bergman, M. and Blomqvist, V. and Martin, T.},
  booktitle={Proceedings of the 2004 ACM SIGPLAN workshop on Haskell},
  pages={108--115},
  year={2004},
  organization={ACM}

}
</biblio>