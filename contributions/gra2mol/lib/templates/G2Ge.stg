group G2Ge;

debug() ::= "holaquetalestas"

addAfter(assign, list) ::= "<assign> <list>"

addBefore(assign, list) ::= "<list> <assign>"

normalRule(assign) ::= "<assign>"

rewriteRule(assign, list) ::= <<
<assign> 
	{
	<list>
	}
>>

insertId(id, rule) ::= "<id>=<rule>"

insertIdAggregation(id, rule) ::= "<id>+=<rule>"

insertGrammarOutput(before, after) ::= <<
<before> 

// Autogenerated options
options {
	output=template;
}

<after>
>>

insertOutputIntoOptions(before, after) ::= <<
<before>
	output=template;
<after>
>>

insertGrammarImport(rule) ::= <<

// Autogenerated import
@header {
	import gts.modernization.model.CST.impl.*;
	import gts.modernization.model.CST.*;
	import java.util.Iterator;
}

// Rules
<rule>
>>

insertImportIntoHeader(before, after) ::= <<
<before>
	// Autogenerated Imports
	import gts.modernization.model.CST.impl.*;
	import gts.modernization.model.CST.*;
	import java.util.Iterator;
<after>
>>

insertReturnIntoGrammarRuleReturn(assign) ::= <<
[<assign>, List returnList]
>>

insertRuleReturn(before, after) ::= <<
<before> returns [Node returnNode] 
<after>
>>

createMainRuleHeader(ruleName) ::= <<
	// Create return CST Node
	Node <ruleName>ReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
	<ruleName>ReturnNode.setKind("<ruleName>");

>>

createRuleHeader(ruleName) ::= <<
	// Create return CST Node
	Node <ruleName>ReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
	<ruleName>ReturnNode.setKind("<ruleName>");

>>

createMainRuleFooter(ruleName) ::= <<
	// Returns the Node with CST Leaves/Nodes
	$<ruleName>.returnNode = <ruleName>ReturnNode;
>>

createRuleFooter(ruleName) ::= <<
	// Returns the Node with CST Leaves/Nodes
	$<ruleName>.returnNode = <ruleName>ReturnNode;
>>

createNormalLeaf(ruleName, id, kind, pos, line) ::= <<
    // Create a CST Leaf
	if($<id> != null) {
		Leaf <id>Leaf = CSTFactoryImpl.eINSTANCE.createLeaf();
		<id>Leaf.setKind("<kind>");
		<id>Leaf.setValue($<id>.text);
		<id>Leaf.setPos(<id>.getCharPositionInLine());
		<id>Leaf.setLine(<id>.getLine());
		<ruleName>ReturnNode.getChildren().add(<id>Leaf);
	}

>>

createTokenLeaf(ruleName, id, kind, pos, line) ::= <<
    // Create a Token CST Leaf	
    if($<id> != null) {
		Leaf <id>Leaf = CSTFactoryImpl.eINSTANCE.createLeaf();
 		<id>Leaf.setKind("TOKEN");
 		<id>Leaf.setValue($<id>.text);
		<id>Leaf.setPos(<id>.getCharPositionInLine());
		<id>Leaf.setLine(<id>.getLine());
 		<ruleName>ReturnNode.getChildren().add(<id>Leaf);
 	}

>>

createNode(grammar, ruleName, id, kind, realKind) ::= <<
    // Create a CST Node
	if($<id> != null) {
        for(Iterator it = $<id>.iterator(); it.hasNext(); )  { 
            <grammar>Parser.<realKind>_return r = (<grammar>Parser.<realKind>_return) it.next(); 
            if(r != null && r.returnNode != null) {
            	r.returnNode.setKind("<kind>");
            	<ruleName>ReturnNode.getChildren().add(r.returnNode);
            } 
        }
    }

>>

reuseNode(grammar, ruleName, id, kind) ::= <<
    // Reuse <kind>Node	
	if($<id> != null) {
        for(Iterator it = $<id>.iterator(); it.hasNext(); )  { 
            <grammar>Parser.<kind>_return r = (<grammar>Parser.<kind>_return) it.next(); 
            <kind>Node.getChildren().add(r.returnNode); 
        }
    }

>>

createNode4LeafAggregation(grammar, ruleName, id, pos, line) ::= <<
    // Create a special CST Node for terminal <id> aggregation
	if($<id> != null) {
		Node <id>Node = CSTFactoryImpl.eINSTANCE.createNode();
		<id>Node.setKind("<id>");
		// Iterate over field
		int count = 0;
        for(Iterator it = $<id>.iterator(); it.hasNext(); )  { 
	        Token t = (Token) it.next(); 
	        Leaf <id>Leaf = CSTFactoryImpl.eINSTANCE.createLeaf();
			<id>Leaf.setKind("<id>" + count++);
			<id>Leaf.setValue(t.getText());
			<id>Leaf.setPos(<pos>);
			<id>Leaf.setLine(<line>);
            <id>Node.getChildren().add(<id>Leaf); 
        }
		<ruleName>ReturnNode.getChildren().add(<id>Node);
    }

>>

createPreClosure(control)::= <<

	// Create a special CST Node for terminal <control> aggregation
	if($<control> != null) {
    for(int pos = 0; pos \< $<control>.size(); pos++ )  { 

>>

createTerminalExtractor(grammar, ruleName, id, kind)::= <<
	// Terminal extractor
    if($<id> != null) {
	    Token t = (Token) $<id>.get(pos); 
	    Leaf <id>Leaf = CSTFactoryImpl.eINSTANCE.createLeaf();
		<id>Leaf.setKind("<kind>");
		<id>Leaf.setValue(t.getText());
		<id>Leaf.setPos(t.getCharPositionInLine());
		<id>Leaf.setLine(t.getLine());
		<ruleName>ReturnNode.getChildren().add(<id>Leaf);
	}

>>

createNoTerminalExtractor(grammar, ruleName, id, kind, realKind)::= <<
	// No Terminal extractor
    if($<id> != null) {		
    	<grammar>Parser.<realKind>_return r = (<grammar>Parser.<realKind>_return) $<id>.get(pos); 
    	if(r != null && r.returnNode != null) {
        	r.returnNode.setKind("<kind>");
    		<ruleName>ReturnNode.getChildren().add(r.returnNode);
    	} 
	}

>>

createPostClosure()::= <<
	}
	}


>>

createPrePrefix(control)::= <<

	// Create a special CST Node for <control> prefix
	if($<control> != null) {
	Node <control>ReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
	<control>ReturnNode.setKind("<control>");

>>

createPostPrefix(ruleName, control)::= <<
	<ruleName>ReturnNode.getChildren().add(<control>ReturnNode)
	}


>>
