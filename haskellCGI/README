== Intent ==

[[Web programming|web programming]] with [[Technology:CGI]] in [[Language:Haskell]]

== Languages ==

* [[Language:Haskell]]
* [[Language:XHTML]]
* [[Language:CSS]]

== Technologies ==

* [[Technology:CGI]]
* [[Technology:GHC]]      

== Features ==

* [[101feature:Company]]
* [[101feature:Total]]
* [[101feature:Cut]]
* [[101feature:Interaction]]
* [[101feature:Distribution]]

== Motivation ==

We make use of the [[Technology:CGI]] library for Haskell to provide a C/S  [[Web Application|web application]] for [[101feature:Company|companies]]. 
That is we exercise processing [[HTTP Request|requests]] from and returning [[HTTP Respond|responds]] to a web client using the CGI technology. We extract request parameters from the [[URL]] like the '''Action''' to either view or [[101feature:Cut|cut]] a company/department/employee or to save an edited company/department/employee. By passing a focus parameter in the URL and by making use of the [[Zipper]] concept we specify the which part of the company should be displayed. We also demonstrate the use of a [[Language:XHTML]] combinator [[:Category:Library|library]] to compose the new pages. 

== Illustration ==

In the ''main'' module (in [this!!Main]) the server is set up:

<syntaxhighlight lang="haskell" line>
main = runCGI $ handleErrors cgiMain
</syntaxhighlight>

We use a default error handler provided by the CGI library ''Network.CGI''. <syntaxhighlight lang="haskell" enclose="none">cgiMain</syntaxhighlight> is the main request handler, which definition is shown in the next section.
In the following we will demonstate how a specific request is processed by the server.

=== Cutting an employee's salary ===

'''Scenario:''' After requesting to view an employee the user clicks the cut button in the browser. The browser sends a request to the server using this URL:

''<nowiki>http://localhost/cgi-bin/HaskellCgi/company.cgi?focus=EmployeeFocus%20[1,0,0]%200&action=Cut</nowiki>''

Bacause of the fact that the CGI library does not support any extraction of information out of the URL path (as opposed to [[101implementation:happstack|happstack]]), the action and focus parameters are encoded as URL-parameters:

* Focus = EmployeeFocus [1,0,0]
* Action = Cut

==== Main request handler ====

In the ''Response'' module (in [this!!Response.hs]) the main request handler can be found:

<syntaxhighlight lang="haskell" line>
cgiMain :: CGI CGIResult
cgiMain =  do
            f <- getInput "focus"
            let focusP = maybe CompanyFocus read f
            a <- getInput "action"
            let actionP = maybe View read a
            chtml <- (doAction actionP) focusP 
            output . renderHtml . page "101companies WebApp" $ chtml
              where
                doAction ap = case ap of
                  View  -> doView
                  Cut   -> doCut
                  Save  -> doSave 
</syntaxhighlight>

We are working inside the <syntaxhighlight lang="haskell" enclose="none">CGI</syntaxhighlight>-monad, which is provided by the CGI library. In lines 3 and 5 <syntaxhighlight lang="haskell" enclose="none">getInput :: MonadCGI m => String -> m (Maybe String)</syntaxhighlight> tries to get the focus and action input parameters as <syntaxhighlight lang="haskell" enclose="none">String</syntaxhighlight> values, which we then process in lines 4 and 6. If a parameter is set, that is, <syntaxhighlight lang="haskell" enclose="none">getInput</syntaxhighlight> returns <syntaxhighlight lang="haskell" enclose="none">Just a</syntaxhighlight>, we <syntaxhighlight lang="haskell" enclose="none">read</syntaxhighlight> the String to values of <syntaxhighlight lang="haskell" enclose="none">Focus</syntaxhighlight> and <syntaxhighlight lang="haskell" enclose="none">Action</syntaxhighlight>. If a parameters is not set, we use a default focus respectively a default action. 

We then call <syntaxhighlight lang="haskell" enclose="none">doAction</syntaxhighlight>, which is definied in lines 10-13. Based on the <syntaxhighlight lang="haskell" enclose="none">Action</syntaxhighlight> value <syntaxhighlight lang="haskell" enclose="none">doAction</syntaxhighlight> returns one of the action functions <syntaxhighlight lang="haskell" enclose="none">doView</syntaxhighlight>, <syntaxhighlight lang="haskell" enclose="none">doCut</syntaxhighlight> or <syntaxhighlight lang="haskell" enclose="none">doSave</syntaxhighlight>. In this example the <syntaxhighlight lang="haskell" enclose="none">case</syntaxhighlight> expression matches on <syntaxhighlight lang="haskell" enclose="none">Cut</syntaxhighlight> and <syntaxhighlight lang="haskell" enclose="none">doAction</syntaxhighlight> returns <syntaxhighlight lang="haskell" enclose="none">doCut</syntaxhighlight>. After that <syntaxhighlight lang="haskell" enclose="none">cgiMain</syntaxhighlight> applies the focus to the action function in line 7. The action function returns an <syntaxhighlight lang="haskell" enclose="none">Html</syntaxhighlight> value, which is then used in line 8 as the content of a new page, rendered to an HTML document and returned as the <syntaxhighlight lang="haskell" enclose="none">CGIResult</syntaxhighlight>.

==== Cutting the cookie ====

The function <syntaxhighlight lang="haskell" enclose="none">doCut</syntaxhighlight> performs the acutal cut action:

<syntaxhighlight lang="haskell">
doCut :: Focus -> CGI Html
doCut f = do
    c <- tryReadCCookie
    let cutC = readCutWrite f c   
    writeCCookie cutC
    return $ html f cutC
</syntaxhighlight>

First the company cookie is read using <syntaxhighlight lang="haskell" enclose="none">tryReadCCookie</syntaxhighlight>:

<syntaxhighlight lang="haskell" line>
tryReadCCookie = liftM (fromMaybe company) $ 
                   readCookie "companyCookie"
</syntaxhighlight>

This function tries to read the company cookie. If the client does not have this cookie stored, the default company is returned.
<syntaxhighlight lang="haskell" enclose="none">doCut</syntaxhighlight> then calls <syntaxhighlight lang="haskell" enclose="none">readCutWrite</syntaxhighlight>, which reads a company, department or employee based on the focus, cuts it and replaces it within the company (see [this!!Cut.hs] for details). After that the manipulated company is written back into the cookie using <syntaxhighlight lang="haskell" enclose="none">writeCCookie</syntaxhighlight>:

<syntaxhighlight lang="haskell">
writeCCookie s = setCookie $ newCookie "companyCookie" $ 
                  show s   
</syntaxhighlight>

==== Returning HTML ====

After that <syntaxhighlight lang="haskell" enclose="none">doCut</syntaxhighlight> calls <syntaxhighlight lang="haskell" enclose="none">getHtml</syntaxhighlight> passing the focus and the new company:

<syntaxhighlight lang="haskell">
html :: Focus -> Company -> Html
html f = case f of 
  CompanyFocus        -> companyHtml f
  (DeptFocus _)       -> deptHtml f
  (EmployeeFocus _ _) -> employeeHtml f
  (ManagerFocus _)    -> employeeHtml f   
</syntaxhighlight>

Based on the focus <syntaxhighlight lang="haskell" enclose="none">html</syntaxhighlight> calls one of the functions for composing HTML. In this example <syntaxhighlight lang="haskell" enclose="none">case</syntaxhighlight> matches on <syntaxhighlight lang="haskell" enclose="none">(EmployeeFocus _ _)</syntaxhighlight> and <syntaxhighlight lang="haskell" enclose="none">employeeHtml</syntaxhighlight> is called. This function composes HTML for the employee in question using various HTML combinators (see [this!!CompanyHtml.hs] for details).

== Architecture ==

In the ''Main'' module in [this!!Main.hs] the server is set up using request handlers provided by [this!!Response.hs]. The save actions are performed by functionality hosted by [this!!Save.hs]. An algebraic datatype for actions is definied in [this!!Types.hs]. HTML pages are composed in [this!!CompanyHtml.hs].
The algebraic datatype for companies can be found in [this!!Company.hs]. There is also a simple API ([this!!API.hs]) to companies providing reading and writing and getters and setters. A sample company can be found in [this!!SampleCompany.hs]. [this!!Cut.hs] and [this!!Total.hs] provide cut and total functionality.

== Usage ==

* First you need a webserver. In the following we explain the steps for <cite>xampp</cite>.
* Compile to a CGI file using GHC: <syntaxhighlight lang="make">ghc --make -o company.cgi Main.hs</syntaxhighlight>
* Place ''company.cgi'' in the folder ''cgi-bin'' of your XAMPP installation.
* Place [this!!style.css] in the folder ''htdocs'' of your XAMPP installation.
* Open ''http://localhost/cgi-bin/haskellCGI/company.cgi'' in a web browser to see the application's root view.
Compiling and cleaning the project is covered by ''run'' and ''clean'' targets in [this!!Makefile.hs].

== Contributors ==

* {{101contributor|Thomas Schmorleiz|developer}}


== References ==

<biblio>
#xampp bibtex=@online{xampp,
  title = {Apache friends: XAMPP},
  note = {\newline \url{http://www.apachefriends.org/en/xampp.html}}
}
</biblio>