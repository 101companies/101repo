== Intent ==

[[Web programming|web programming]] with [[Technology:CGI]] in [[Language:Haskell]]

== Languages ==

* [[Language:Haskell]]
* [[Language:XHTML]]
* [[Language:CSS]]

== Technologies ==

* [[Technology:CGI]]
* [[Technology:GHC]]      

== Features ==

* [[101feature:Company]]
* [[101feature:Total]]
* [[101feature:Cut]]
* [[101feature:Interaction]]
* [[101feature:Distribution]]

== Motivation ==

We make use of the [[Technology:CGI]] library for Haskell to provide a C/S  [[Web Application|web application]] for [[101feature:Company|companies]]. 
That is we exercise processing [[HTTP Request|requests]] from and returning [[HTTP Respond|responds]] to the client using the CGI technology. We extract request parameters from the [[URL]] like the '''Action''' to either view or [[101feature:Cut|cut]] a company/department/employee or to save an edited company/department/employee. By passing a focus parameter in the URL and by making use of the [[Zipper]] concept we specify the which part of the company should be displayed. We also demonstrate the use of [[Language:XHTML]] [[Combinator|combinators]] to compose the new page. 

== Illustration ==

In the ''main'' module (in [this!!Main]) the server is set up:

<syntaxhighlight lang="haskell>
main = runCGI $ handleErrors cgiMain
</syntaxhighlight>

We use a default error handler provided by the CGI library. <syntaxhighlight lang="haskell enclose="none">cgiMain</syntaxhighlight> is the main request handler.

In the following we will demonstate how a specific request is processed by the server.

=== Cutting an employee's salary ===

After requesting to view an employee the user clicks the cut button in the browser. The browser sends a request to the server using this URL:

'''<nowiki>http://localhost/cgi-bin/HaskellCgi/company.cgi?focus=EmployeeFocus%20[1,0,0]%200&action=Cut</nowiki>'''

Bacause of the fact that the CGI library does not support any extraction of information out of the URL path (as opposed to [[101implementation:happstack|happstack]]), the action and focus parameters are encoded as URL-parameters:

* Focus = EmployeeFocus [1,0,0]
* Action = Cut

==== Main request handler ====

In the ''Response'' module (in [this!!Response.hs]) the main request handler can be found:

<syntaxhighlight lang="haskell>
cgiMain :: CGI CGIResult
cgiMain =  do
            f <- getInput "focus"
            let focusP = maybe CompanyFocus read f
            a <- getInput "action"
            let actionP = maybe View read a
            html <- (doAction actionP) focusP 
            output . renderHtml . page "101companies WebApp" $ html
              where
                doAction ap = case ap of
                  View  -> doView
                  Cut   -> doCut
                  Save  -> doSave 
</syntaxhighlight>

We are working inside the <syntaxhighlight lang="haskell enclose="none">CGI</syntaxhighlight>-monad, which is provided by the library. The <syntaxhighlight lang="haskell enclose="none">getInput</syntaxhighlight> function tries to <syntaxhighlight lang="haskell enclose="none">read</syntaxhighlight> values of the <syntaxhighlight lang="haskell enclose="none">Action</syntaxhighlight> respectively <syntaxhighlight lang="haskell enclose="none">Focus</syntaxhighlight> datatypes out of the URL. In this example the <syntaxhighlight lang="haskell enclose="none">case</syntaxhighlight> expression matches on <syntaxhighlight lang="haskell enclose="none">Cut</syntaxhighlight> and <syntaxhighlight lang="haskell enclose="none">cgiMain</syntaxhighlight> calls <syntaxhighlight lang="haskell enclose="none">doCut</syntaxhighlight> passing the focus. <syntaxhighlight lang="haskell enclose="none">doCut</syntaxhighlight> returns a <syntaxhighlight lang="haskell enclose="none">Html</syntaxhighlight> value based on the given focus. The result is then used as the content of a new page, which is then rendered to an HTML document and returned as the <syntaxhighlight lang="haskell enclose="none">CGIResult</syntaxhighlight>.

==== Cutting the cookie ====

The "cutting handler" <syntaxhighlight lang="haskell enclose="none">doCut</syntaxhighlight> performs the acutal cut action:

<syntaxhighlight lang="haskell>
doCut :: Focus -> CGI Html
doCut f = do
    c <- tryReadCCookie
    let cutC = readCutWrite f c   
    writeCCookie cutC
    return $ html f cutC
</syntaxhighlight>

First the company cookie is read using <syntaxhighlight lang="haskell enclose="none">tryReadCCookie</syntaxhighlight>:

<syntaxhighlight lang="haskell>
tryReadCCookie = liftM (fromMaybe company) $ readCookie "companyCookie"
</syntaxhighlight>

This function tries to read the company cookie. If the client does not have this cookie stored, the default company is returned.

<syntaxhighlight lang="haskell enclose="none">doCut</syntaxhighlight> then calls <syntaxhighlight lang="haskell enclose="none">readCutWrite</syntaxhighlight>, which reads a company, department or employee based on the focus, cuts it and replaces it within the company (see [this!!Cut.hs] for details). After that manipulated company is written back into the cookie using <syntaxhighlight lang="haskell enclose="none">writeCCookie</syntaxhighlight>:

<syntaxhighlight lang="haskell>
writeCCookie = setCookie.(newCookie "companyCookie").show
</syntaxhighlight>

==== Returning HTML ====

After that <syntaxhighlight lang="haskell enclose="none">doCut</syntaxhighlight> calls <syntaxhighlight lang="haskell enclose="none">html</syntaxhighlight> passing the focus and the new company:

<syntaxhighlight lang="haskell>
html :: Focus -> Company -> Html
html f = case f of 
  CompanyFocus        -> companyHtml f
  (DeptFocus _)       -> deptHtml f
  (EmployeeFocus _ _) -> employeeHtml f
  (ManagerFocus _)    -> employeeHtml f   
</syntaxhighlight>

Based on the focus <syntaxhighlight lang="haskell enclose="none">html</syntaxhighlight> calls <syntaxhighlight lang="haskell enclose="none">employeeHtml</syntaxhighlight>, which composes html for the employee in question using various html combinators (see [this!!CompanyHtml.hs] for details).

== Architecture ==

In the ''Main'' module in [this!!Main.hs] the server is set up using request handlers provided by [this!!Response.hs]. The save actions are performed by functionality hosted by [this!!Save.hs]. An algebraic datatype for actions is definied in [this!!Types.hs]. HTML pages are composed in [this!!CompanyHtml.hs].
The algebraic datatype for companies can be found in [this!!Company.hs]. There is also a simple API ([this!!API.hs]) to companies providing reading and writing and getters and setters. A sample company can be found in [this!!SampleCompany.hs]. [this!!Cut.hs] and [this!!Total.hs] provide cut and total functionality.

== Usage ==

* First you need a webserver. In the following we explain the steps for [http://www.apachefriends.org/en/xampp.html XAMPP].
* Compile to a CGI file using GHC: <syntaxhighlight lang="make">ghc --make -o company.cgi Main.hs</syntaxhighlight>
* Place ''company.cgi'' in the folder ''cgi-bin'' of your XAMPP installation.
* Place [this!!style.css] in the folder ''htdocs'' of your XAMPP installation.
* Open http://localhost/cgi-bin/haskellCGI/company.cgi in a web browser to see the application's root view.

Compiling and cleaning the project is covered by ''run'' and ''clean'' targets in [this!!Makefile.hs].

== Contributors ==

* {{101contributor|Thomas Schmorleiz|developer}}