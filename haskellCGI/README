== Intent ==

[[Web programming|web programming]] with [[Technology:CGI]] in [[Language:Haskell]]

== Languages ==

* [[Language:Haskell]]
* [[Language:XHTML]]
* [[Language:CSS]]

== Technologies ==

* [[Technology:CGI]]
* [[Technology:GHC]]      

== Features ==

* [[101feature:Company]]
* [[101feature:Total]]
* [[101feature:Cut]]
* [[101feature:Interaction]]
* [[101feature:Distribution]]

== Motivation ==

We make use of the [[Technology:CGI]] library for Haskell to provide a C/S  [[Web Application|web application]] for [[101feature:Company|companies]]. 
On every CGI page [[HTTP Request|request]] we extract the request parameters. There is an action parameter to either view or cut
a company/department/employee or to save an edited company/department/employee. 
With the supplied focus parameter and by using the [[Zipper|zipper]] concept 
we read the correct company/department/employee to be viewed/cut/saved from the client-sided cookie. 
We then use [[Language:XHTML]] [[Combinator|combinators]] to compose the new page. This page is returned to the client as the 
CGI [[HTTPRespose|response]].  

== Illustration ==

In the ''main'' module (in [this!!Main]) the server is set up like this:

<syntaxhighlight lang="haskell>
main = runCGI $ handleErrors cgiMain
</syntaxhighlight>

We use a default error handler. <syntaxhighlight lang="haskell enclose="none">cgiMain</syntaxhighlight> is the main request handler.

In the following we will demonstate how a specific request is processed by the server.

=== Cutting an employee's salary ===

After requesting to view an employee the user clicks the cut button in the browser. The browser sends a request to the server using this URL:

'''<nowiki>http://localhost/cgi-bin/HaskellCgi/company.cgi?focus=EmployeeFocus%20[1,0,0]%200&action=Cut</nowiki>'''

Bacause of the fact that the CGI library does not support any extraction of information out of the URL path (as opposed to [[101implementation:happstack|happstack]]), the action and focus parameters are encoded as URL-parameters:

* Focus = EmployeeFocus [1,0,0]
* Action = Cut

In the ''Response'' module (in [this!!Response.hs]) the main response handler can be found

<syntaxhighlight lang="haskell>
cgiMain :: CGI CGIResult
cgiMain =  do
            f <- getInput "focus"
            let focusP = maybe CompanyFocus read f
            a <- getInput "action"
            let actionP = maybe View read a
            html <- (doAction actionP) focusP 
            output . renderHtml . page "101companies WebApp" $ html
              where
                doAction ap = case ap of
                  View  -> doView
                  Cut   -> doCut
                  Save  -> doSave 
</syntaxhighlight>

We are working inside the <syntaxhighlight lang="haskell enclose="none">CGI</syntaxhighlight>-monad, which is provided by the library.The <syntaxhighlight lang="haskell enclose="none">getInput</syntaxhighlight> function tries to <syntaxhighlight lang="haskell enclose="none">read</syntaxhighlight> to the <syntaxhighlight lang="haskell enclose="none">Action</syntaxhighlight> respectively <syntaxhighlight lang="haskell enclose="none">Focus</syntaxhighlight> datatypes. In this example the <syntaxhighlight lang="haskell enclose="none">case</syntaxhighlight> expression matches on <syntaxhighlight lang="haskell enclose="none">Cut</syntaxhighlight> and <syntaxhighlight lang="haskell enclose="none">cgiMain</syntaxhighlight> calls <syntaxhighlight lang="haskell enclose="none">doCut</syntaxhighlight> passing the focus. <syntaxhighlight lang="haskell enclose="none">doCut</syntaxhighlight> composes <syntaxhighlight lang="haskell enclose="none">Html</syntaxhighlight> based on the given focus. The result is then used as the content of a new page, which is then rendered to an HTML document and returned as the <syntaxhighlight lang="haskell enclose="none">CGIResult</syntaxhighlight>.

<syntaxhighlight lang="haskell enclose="none">doCut</syntaxhighlight> performs the acutal cut action:

<syntaxhighlight lang="haskell>
doCut f = do
    c <- tryReadCCookie
    let cutC = readCutWrite f c   
    writeCCookie cutC
    return $ html f cutC
</syntaxhighlight>

First the company cookie is read using <syntaxhighlight lang="haskell enclose="none">tryReadCCookie</syntaxhighlight>:

<syntaxhighlight lang="haskell>
tryReadCCookie = liftM (fromMaybe company) $ readCookie "companyCookie"
</syntaxhighlight>

This function tries to read the company cookie. If the client does not have this cookie, the default company is returned.

<syntaxhighlight lang="haskell enclose="none">doCut</syntaxhighlight> then calls <syntaxhighlight lang="haskell enclose="none">readCutWrite</syntaxhighlight>, which reads a company, department or employee based on the focus, cuts it and replaces it within the company (see [this!!Cut.hs] for details). After that manipulated company is written back into the cookie using <syntaxhighlight lang="haskell enclose="none">writeCCookie</syntaxhighlight>:

<syntaxhighlight lang="haskell>
writeCCookie = setCookie.(newCookie "companyCookie").show
</syntaxhighlight>

After that <syntaxhighlight lang="haskell enclose="none">html</syntaxhighlight> is called passing the focus and the new company:

<syntaxhighlight lang="haskell>
html :: Focus -> Company -> Html
html f = case f of 
  CompanyFocus        -> companyHtml f
  (DeptFocus _)       -> deptHtml f
  (EmployeeFocus _ _) -> employeeHtml f
  (ManagerFocus _)    -> employeeHtml f   
</syntaxhighlight>

Based on the focus <syntaxhighlight lang="haskell enclose="none">html</syntaxhighlight> calls <syntaxhighlight lang="haskell enclose="none">employeeHtml</syntaxhighlight>, which composes html for the employee in question using various html combinators (see [this!!CompanyHtml.hs] for details).


== Architecture ==

[this!!Cut.hs] and [this!!Total.hs] provide cut and total functionality. The algebraic datatype for companies can be found in
[this!!Company.hs]. There is also a simple API ([this!!API.hs]) to companies providing reading and writing (see [[#Motivation|Motivation]]) and getters and setters.
Requests are processed by [this!!Request.hs], which is using the ''Action'' datatype in [this!!Action.hs].
Pages are composed in [this!!CompanyHtml.hs].

== Usage ==

* First you need to setup a webserver. One might use [http://www.apachefriends.org/en/xampp.html XAMPP].
* Place this implementation (except [this!!style.css]) in the folder ''cgi-bin'' of your XAMPP installation.
* Place [this!!style.css] in the folder ''htdocs'' of your XAMPP installation.
* Open http://localhost/cgi-bin/haskellCGI/company.cgi in a web browser.

== Contributors ==

* {{101contributor|Thomas Schmorleiz|developer}}