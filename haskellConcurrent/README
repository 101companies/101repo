== Intent ==

task parallel programming in [[Language:Haskell]]

== Languages ==

* [[Language:Haskell 98]]

== Technologies ==

* [[Technology:GHCi]]      

== Features ==

* [[101feature:Company]]
* [[101feature:Total]]
* [[101feature:Cut]]
* [[101feature:Parallelism]]

== Motivation ==

We make use of [[Language:Haskell]]'s [[Concurrency]] support. That is, we are using synchronized variables ([[MVar]]), which are shared among different threads. 
Each thread [[101feature:Total|totals]] resp. [[101feature:Cut|cuts]] only the salaries in a specifed department; subdepartments are handled by new threads.
The result of the computations (float values resp. new company entities) are stored in a MVar and then collected and aggregated with other results by the "upper" thread. 
We also demonstrate the use of tryTakeMVar by implementating an aggregation function that collects all mvars values in a list of mvars, but does not block on every element (see [[#Illustration|Illustration]]).    

== Illustration ==

=== Cutting in parallel ===

We create a new thread using <syntaxhighlight lang="haskell" enclose="none">forkIO :: IO () -> IO ThreadId</syntaxhighlight> provided by Haskell's concurrency library <syntaxhighlight lang="haskell" enclose="none">Control.Concurrent</syntaxhighlight>. This function executes the given IO action in a new thread and returns a <syntaxhighlight lang="haskell" enclose="none">ThreadId</syntaxhighlight> value. On the top company level we do this for every department (code can be found in [this!!Cut.hs]):

<syntaxhighlight lang="haskell">
cutCompany :: Company -> IO Company
cutCompany (Company n depts) = do
    cuts <- forM depts $ \d -> do
        mvar' <- newEmptyMVar
        forkIO $ cutDept mvar' d
        return mvar'
    cutDepts <- takeAllMVars cuts
    return $ Company n cutDepts
</syntaxhighlight>

We collect all <syntaxhighlight lang="haskell" enclose="none">ThreadId</syntaxhighlight> values in <syntaxhighlight lang="haskell" enclose="none">cuts</syntaxhighlight>. Analogous to this we cut departments:

<syntaxhighlight lang="haskell">
cutDept :: MVar Department -> Department -> IO ()
cutDept mvar (Department n m dus eus) = do
    cuts <- forM dus $ \d -> do
        mvar' <- newEmptyMVar
        forkIO $ cutDept mvar' d
        return mvar'
    cutDus <- takeAllMVars cuts
    putMVar mvar $ Department n (cutEmployee m) (cutDus) (map cutEmployee eus)  
</syntaxhighlight>

The cutting of direct department employees not performed in a new thread:

<syntaxhighlight lang="haskell">
cutEmployee :: Employee -> Employee
cutEmployee (Employee name address salary) = Employee name address $ salary / 2
</syntaxhighlight>

=== Collecting results ===

Both functions <syntaxhighlight lang="haskell" enclose="none">cutCompany</syntaxhighlight> and <syntaxhighlight lang="haskell" enclose="none">cutDept</syntaxhighlight> need to wait for the child-threads to terminate. To do so we provide a function <syntaxhighlight lang="haskell" enclose="none">takeAllMVars</syntaxhighlight> in the ''Utils'' module (in [this!!Utils.hs]):

<syntaxhighlight lang="haskell">
takeAllMVars ::  [MVar a] -> IO [a]
takeAllMVars [] = return []
takeAllMVars (m:ms) = do
    x <- tryTakeMVar m
    f x
    where
        f (Just y) = do
            ys <- takeAllMVars ms
            return $ y:ys
        f (Nothing) = do
            ys <- takeAllMVars $ rotate $ m:ms
            return $ derotate ys
</syntaxhighlight> 

This function tries to take the value out of the <syntaxhighlight lang="haskell" enclose="none">MVar</syntaxhighlight> at the head of the given list. If this fails, because the <syntaxhighlight lang="haskell" enclose="none">MVar</syntaxhighlight> is empty, the list is rotated and applied to <syntaxhighlight lang="haskell" enclose="none">takeAllMVars</syntaxhighlight> again. This time the function tries to take the content of the second <syntaxhighlight lang="haskell" enclose="none">MVar</syntaxhighlight> of the intital list. If talking succeeds, the value is collected and the tail of the list is applied to <syntaxhighlight lang="haskell" enclose="none">takeAllMVars</syntaxhighlight>. This process continues until all values are collected.

=== Executing cut ===

In the ''Main'' module in [this!!Main.hs] we execute the talk parallel cut on a sample company. Because <syntaxhighlight lang="haskell" enclose="none">cut</syntaxhighlight> is not pure, we are working in the IO monad:
<syntaxhighlight lang="haskell">
cutCompany <- cutCompany company
</syntaxhighlight> 

== Architecture ==

[this!!Total.hs] and [this!!Cut.hs] provide functionality to total and cut salaries in a concurrent way. 
[this!!Utils.hs] contains a function to collect contents all <syntaxhighlight lang="haskell" enclose="none">MVar</syntaxhighlight> list in a non-blocking way.
The algebraic datatype for companies can be found in [this!!Company.hs]. 
The ''main'' module (in [this!!Main.hs]) collects test scenarios for totaling and cutting a sample company hosted by [this!!SampleCompany.hs].

== Usage ==

* The Haskell module ''Main'' has to be run using GHCi, and the ''main'' function has to be applied.  
* The output should be equal to the content of [this!!basefile]

Both steps are covered by the target ''test'' in [this!!Makefile]. Use the ''clean'' target to "reset" the project.

== Contributors ==

* {{101contributor|Thomas Schmorleiz|developer}}