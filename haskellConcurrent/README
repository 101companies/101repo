== Intent ==

task parallel programming in [[Language:Haskell]]

== Languages ==

* [[Language:Haskell]]

== Technologies ==

* [[Technology:GHCi]]      

== Features ==

* [[101feature:Company]]
* [[101feature:Total]]
* [[101feature:Cut]]
* [[101feature:Parallelism]]

== Motivation ==

We make use of [[Language:Haskell]]'s [[Concurrency]] support. That is, we devide computations into multiple threads and make use of synchronized variables ([[MVar]]), which are shared among different threads. 
Each thread [[101feature:Total|totals]] or [[101feature:Cut|cuts]] only the salaries in a specifed department; subdepartments are handled by new threads.
The result of the computations (float values resp. new company entities) are stored in a MVar and then collected and aggregated with other results by the "upper" thread. 
We demonstrate the use of <syntaxhighlight lang="haskell" enclose="none">tryTakeMVar</syntaxhighlight> by implementating an aggregation function that collects all mvars values in a list of MVars, but does not block on every element.    

== Illustration ==

=== Cutting in parallel ===

We create a new thread using <syntaxhighlight lang="haskell" enclose="none">forkIO :: IO () -> IO ThreadId</syntaxhighlight> provided by Haskell's concurrency library <syntaxhighlight lang="haskell" enclose="none">Control.Concurrent</syntaxhighlight>. This function executes the given IO action in a new thread and returns a <syntaxhighlight lang="haskell" enclose="none">ThreadId</syntaxhighlight> value. On the top company level we do this for every department (code can be found in [this!!Cut.hs]):

<syntaxhighlight lang="haskell">
cutCompany :: Company -> IO Company
cutCompany (Company n depts) = do
    threads <- forM depts $ \d -> do
        mvar' <- newEmptyMVar
        forkIO $ cutDept mvar' d
        return mvar'
    cutDepts <- takeAllMVars threads
    return $ Company n cutDepts
</syntaxhighlight>

We collect all <syntaxhighlight lang="haskell" enclose="none">ThreadId</syntaxhighlight> values in <syntaxhighlight lang="haskell" enclose="none">cuts</syntaxhighlight>. Analogous to this we cut departments:

<syntaxhighlight lang="haskell">
cutDept :: MVar Department -> Department -> IO ()
cutDept mvar (Department n m dus eus) = do
    threads <- forM dus $ \d -> do
        mvar' <- newEmptyMVar
        forkIO $ cutDept mvar' d
        return mvar'
    cutDus <- takeAllMVars threads
    putMVar mvar $ Department n (cutEmployee m) (cutDus) (map cutEmployee eus)  
</syntaxhighlight>

The cutting of direct department employees is not performed in a new thread:

<syntaxhighlight lang="haskell">
cutEmployee :: Employee -> Employee
cutEmployee (Employee name address salary) = Employee name address $ salary / 2
</syntaxhighlight>

=== Collecting results ===

Both functions <syntaxhighlight lang="haskell" enclose="none">cutCompany</syntaxhighlight> and <syntaxhighlight lang="haskell" enclose="none">cutDept</syntaxhighlight> need to wait for the child-threads to terminate. To do so we provide a function <syntaxhighlight lang="haskell" enclose="none">takeAllMVars</syntaxhighlight> in the ''Utils'' module (in [this!!Utils.hs]):

<syntaxhighlight lang="haskell">
takeAllMVars ::  [MVar a] -> IO [a]
takeAllMVars [] = return []
takeAllMVars (m:ms) = do
    x <- tryTakeMVar m
    f x
    where
        f (Just y) = do
            ys <- takeAllMVars ms
            return $ y:ys
        f (Nothing) = do
            ys <- takeAllMVars $ rotate $ m:ms
            return $ derotate ys
</syntaxhighlight> 

This function tries to take the value out of the <syntaxhighlight lang="haskell" enclose="none">MVar</syntaxhighlight> at the head of the given list. If this fails, because the <syntaxhighlight lang="haskell" enclose="none">MVar</syntaxhighlight> is empty, the list is rotated and applied to <syntaxhighlight lang="haskell" enclose="none">takeAllMVars</syntaxhighlight> again. This time the function tries to take the content of the second <syntaxhighlight lang="haskell" enclose="none">MVar</syntaxhighlight> of the intital list. If talking succeeds, the value is collected and the tail of the list is applied to <syntaxhighlight lang="haskell" enclose="none">takeAllMVars</syntaxhighlight>. This process continues until all values are collected.


== Architecture ==

[this!!Total.hs] and [this!!Cut.hs] provide functionality for totaling and cutting salaries in a concurrent way. 
[this!!Utils.hs] contains a function to collect content of a list of <syntaxhighlight lang="haskell" enclose="none">MVar</syntaxhighlight> values in a non-blocking way.
The algebraic datatype for companies can be found in [this!!Company.hs]. 
The ''main'' module (in [this!!Main.hs]) collects test scenarios for totaling and cutting a sample company hosted by [this!!SampleCompany.hs].

== Usage ==

* The Haskell module ''Main'' (hosted by [this!!Main.hs]) has to be loaded into GHCi. 
* The <syntaxhighlight lang="haskell" enclose="none">main</syntaxhighlight> function has to be applied.
* The output should be equal to the content of the file [this!!baseline].
* One can also use the [this!!Makefile] with a target ''test'' for [[test automation]].
* Use the taget ''clean'' to "reset" the project.

== Contributors ==

* {{101contributor|Thomas Schmorleiz|developer}}