== Intent ==

Provide [[101feature:Interaction|interaction]] on companies by means of [[Technology:wxHaskell]]

== Languages ==

* [[Language:Haskell]]

== Technologies ==

* [[Technology:wxHaskell]]
* [[Technology:GHC]]
* [[Technology:GHCi]]      

== Features ==

* [[101feature:Company]]
* [[101feature:Total]]
* [[101feature:Cut]]
* [[101feature:Interaction]]

== Motivation ==

We use the [[Technology:wxHaskell]] library to provide a simple GUI for [[101feature:Company|companies]]. 
One can navigate the hierachical company structure, [[101feature:Cut|cut]] salaries and edit fields of [[Primitive Type|primitive types]]. 
We make use the [[Zipper|zipper]] concept to specify which part of the company should be shown or saved after editing.
This concept also helps us to read departments/employees from a given position within the company and write manipulated departments/employees back.  

== Illustration ==

=== Zipper ===

By using the concept of zippers we specify positions of components within the company. In the ''API'' module we provide a algebraic datatype <syntaxhighlight lang="haskell" enclose="none">Focus</syntaxhighlight>:

<syntaxhighlight lang="haskell" line>
data Focus = 
     CompanyFocus
   | DeptFocus [Int]
   | ManagerFocus [Int]
   | EmployeeFocus [Int] Int
    deriving (Show, Read)
</syntaxhighlight>

There is one contructor per company datatype. For example for employees one needs to pass:
* A list of indexes: Starting from the company root this list is used to navigate through the subdepartments.
* An index: The index of this employee in the department's employees list.

We now provide various focus functions (see [this!!API.hs] for details):

* given a focus for a company component, compute the focus of the upper component
* given a company/department focus, compute the list of subdeparments/employees foci
* reading a specific component out of a given company 
* writing, say replacing, a specific component within the company

In the following we will demonstrate reading.

==== Reading ====

We can now provide a function to read a company component given a focus and a company:

<syntaxhighlight lang="haskell" line>
class Readable a where
    readA :: Focus -> Company -> a
</syntaxhighlight>

An instance declaration for departments looks like this:

<syntaxhighlight lang="haskell" line>
instance Writeable Department where
    writeA = writeDepartment

readDepartment :: Focus -> Company -> Department
readDepartment (DeptFocus ns) (Company _ depts) = readStep ns depts                 
    where
        readStep [n] depts = depts !! n
        readStep (n:ns) depts = readStep ns $ getDus $ depts !! n
</syntaxhighlight>

Using the given index list <syntaxhighlight lang="haskell" enclose="none">ns</syntaxhighlight>, <syntaxhighlight lang="haskell" enclose="none">readDepartment</syntaxhighlight> navigates through the company until it reaches the department in question.



=== Starting the GUI ===

In the ''Main'' module we use xwHaskell's <syntaxhighlight lang="haskell" enclose="none">start :: IO a -> IO ()</syntaxhighlight>. This function runs the given GUI of type <syntaxhighlight lang="haskell" enclose="none">IO a</syntaxhighlight> while discarding <syntaxhighlight lang="haskell" enclose="none">a</syntaxhighlight> and returning <syntaxhighlight lang="haskell" enclose="none">IO ()</syntaxhighlight> (code can be found in [this!!Main.hs]):

<syntaxhighlight lang="haskell" line>
gui :: IO ()
gui = do
    f <- frame [ textBgcolor := colorRGB 112 128 144 
               , resizeable := False
               , fontWeight := WeightBold
               , fontUnderline := False
               , position := Point 50 50]
    showCompany f CompanyFocus company 

main :: IO ()
main = start gui
</syntaxhighlight>

<syntaxhighlight lang="haskell" enclose="none">gui</syntaxhighlight> creates the main frame for all views passing a list attributes, which are assigned by making use of assign operator <syntaxhighlight lang="haskell" enclose="none">(:=)</syntaxhighlight>. After that the function calls <syntaxhighlight lang="haskell" enclose="none">showCompany</syntaxhighlight> passing the frame, the root focus and a sample company provided by the ''SampleCompany'' module (in [this!!SampleCompany.hs]).

=== The views ===

For each company data type, that is <syntaxhighlight lang="haskell" enclose="none">Company</syntaxhighlight>, <syntaxhighlight lang="haskell" enclose="none">Department</syntaxhighlight> and <syntaxhighlight lang="haskell" enclose="none">Employee</syntaxhighlight>, the ''Views'' module (in [this!!Views.hs]) provides a view to display the specific component including buttons to cut and save. All of these functions are of type <syntaxhighlight lang="haskell" enclose="none">Frame () -> Focus -> Company -> IO ()</syntaxhighlight>. That is, given the global frame, a focus and a company these functions perform GUI actions (which are IO actions). 

In the following we demonstrate how an employee is displayed.

==== Viewing an employee ====

<syntaxhighlight lang="haskell" enclose="none">viewEmployee</syntaxhighlight> provides a view for employees. 

<syntaxhighlight lang="haskell" line>
viewEmployee :: Frame () -> Focus -> Company -> IO ()
viewEmployee f focus c = do
    -- reading employee
    let e = readEM focus c
    -- setting up frames and panels
    set f [ text := "Employee \"" ++ getEName e ++ "\""]
    p <- panel f [textColor := textBlue]
    -- boxes for name, address and salary
    nameBox <- entry p [text := getEName e]                                    
    addressBox <- entry p [text := getAddress e]
    salaryBox <- entry p [text := show $ getSalary e]
    -- cut button
    cButton <- cutButton p f focus c
    -- back button                                
    bButton <- backButton p f focus c           
    -- save button                                                             
    sButton <- button  p [ text := "Save"
                         , size := Size 50 22 
                         , on command := do { 
                             newName <- get nameBox text;
                             newAddress <- get addressBox text;
                             newSalary <- get salaryBox text;
                             objectDelete p;
                             newc <- return $ (writeEM focus c (Employee newName newAddress (read newSalary)));
			     viewEmployee f focus newc; }]
    -- compose layout                                 
    set f [layout := container p $ alignCentre $
                     margin 20 $   
                     column 10 [
                        alignLeft $ row 10 [widget sButton, widget bButton],
                        hrule 250,
                        alignCentre $ row 94 [label "Name:", widget nameBox],
                        alignCentre $ row 81 [label "Address:", widget addressBox],
                        alignCentre $ row 91 [label "Salary:", widget salaryBox],
                        alignRight $ margin 10 $ widget cButton
                     ]]       
</syntaxhighlight>


In line 4 we read the employee in question using the ''API'' module (can be found in [this!!API.hs]). After that we set the frame title and create a new panel for this view. In lines 9-11 we create one input box per employee field. We than create buttons to cut the employee's salary and to go back to the department level. In lines 17-25 we set up a save button. When an user clicks the button, the name, address and salary fields are read, the panel is deleted, the employee updated in the company and then shown. After that we use various layout combinators to compose all GUI elements.

=== Cutting button ===

On each view the GUI provides a button to cut all salaries: 

<syntaxhighlight lang="haskell" line>
cutButton :: Panel () -> Frame () -> Focus -> Company -> IO (Button ())
cutButton p f focus c = button p [ text := "Cut"      
                                 , size := Size 50 22                                                                
                                 , on command := do {
                                      objectDelete p; 
                                      view f focus $ readCutWrite focus c;}] 
                     ]]       
</syntaxhighlight>

When the user clicks the button the <syntaxhighlight lang="haskell" enclose="none">command</syntaxhighlight> action is executed. First the view's panel is deleted. After that we use <syntaxhighlight lang="haskell" enclose="none">readCutWrite</syntaxhighlight> hosted by the ''Cut'' module (in [this!!Cut.hs]) to cut the company component's salaries. This function reads the component in question based on the focus, then cuts this component's salaries and replaces it in the given company. After that the <syntaxhighlight lang="haskell" enclose="none">command</syntaxhighlight> action calls <syntaxhighlight lang="haskell" enclose="none">view</syntaxhighlight> to view the company, department or employee. Based on the focus <syntaxhighlight lang="haskell" enclose="none">view</syntaxhighlight> decided which concrete view-function to call:

<syntaxhighlight lang="haskell" line>
view:: Frame () -> Focus -> Company -> IO ()
view f focus = view' f focus
  where 
    view' = case focus of
              CompanyFocus        -> viewCompany
              (DeptFocus _)       -> viewDept
              (EmployeeFocus _ _) -> viewEmployee
              (ManagerFocus _)    -> viewEmployee       
</syntaxhighlight>


== Architecture ==

[this!!Views.hs] provides one view per company data type. The ''Main'' module in [this!!Main.hs] starts the GUI. The algebraic datatype for companies can be found in [this!!Company.hs], a sample company in [this!!SampleCompany.hs]. There is also an API to the company hosted by [this!!API.hs]. [this!!Total.hs] and [this!!Cut.hs] provide functionality to total and cut salaries.

== Usage ==

The ''Main'' module has to be compiled using GHC the output executable has to run. There is a ''Makefile'' with a target ''start'' covering both stepts. Also, there is a ''clean'' target to "reset" the project.

== Contributors ==

* {{101contributor|Thomas Schmorleiz|developer}}