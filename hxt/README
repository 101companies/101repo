== Intent ==

[[in-memory XML processing]] with [[Technology:HXT]] in [[Language:Haskell]]

== Languages ==

* [[Language:XML]]
* [[Language:Haskell]]

== Technologies ==

* [[Technology:HXT]]: Haskell XML Toolbox
* [[Technology:GHCi]]

== Features ==

* [[101feature:Company]]
* [[101feature:Total]]
* [[101feature:Cut]]
* [[101feature:Serialization]]

== Motivation ==

[[101feature:Company|Companies]] are represented in [[Language:XML]] and the [[Technology:HXT|Haskell XML Toolbox]] is used for processing such company-xml-data.
That is, we use a rich combinator library to formulate a query for [[101feature:Total|totaling]] and a transformation for [[101feature:Cut|cutting]] salaries in a given company-xml-tree.
The concept of [[Arrow|arrows]] is also heavily demonstrated in this implementation, because the combinator library is based on this concept. That is we exercise:
* Using arrow combinators such as ''>>>'' and ''`when`''.
* Lifing ordinary functions into the arrow space using ''arr''.
* Using ''Control.Arrow.ArrowList'''s ''listA'' for collecting all arrow results in a list.
* Executing these arrows, say switching between arrows and the IO [[monad|Monad]] space (See the illustration section).


== Illustration ==

Consider the following HXT/Arrow-based implementation of [[101feature:Total|total]]:

<syntaxhighlight lang="haskell">
total :: ArrowXml a => a XmlTree Float
total = listA (deep $ hasName "salary"
               >>> 
               getChildren  
               >>> 
               getText)     
        >>>
        arr (sum.(map read)) 
</syntaxhighlight>

First we want to get all salary nodes:

<syntaxhighlight lang="haskell"> deep $ hasName "salary"</syntaxhighlight> 

This is an arrow from XmlTree to XmlTree, say a '''filter''' for all salary nodes. In general ''deep'' only works for non-nested results, but because of the fact that we are dealing with text nodes, which can not be nested, this is ok.

The result of this node is then combined with <syntaxhighlight lang="haskell" enclose="none">getChildren >>> getText</syntaxhighlight> by using <syntaxhighlight lang="haskell">>>></syntaxhighlight>. 
This gives us the text of each salary node. So the combination has the type: <syntaxhighlight lang="haskell" enclose="none">ArrowXml a => a XmlTree String</syntaxhighlight> 

We then use ''Control.Arrow.ArrowList'''s ''listA'' to collect all these texts in an array, giving us an arrow of type: <syntaxhighlight lang="haskell" enclose="none">ArrowXml a => a XmlTree [String]</syntaxhighlight> 

The result of this arrow is then passed to the lifted version of
<syntaxhighlight lang="haskell">(sum.(map read)) :: (Read c, Num c) => [String] -> c</syntaxhighlight>
which in this case is of type:
<syntaxhighlight lang="haskell">ArrowXml a => a [String] Float</syntaxhighlight>
giving us the total of all salaries.

== Architecture ==



== Usage ==

The Haskell module ''Main'' has to be consulted with GHCi, and the
''main'' function has to be applied so that output for the test
scenarios is produced. The ''expected'' output is available through
the file ''baseline''. There is a ''Makefile'' with a target ''test''
for [[test automation]].
Use the taget ''clean'' to "reset" the project.

== Contributors ==

* {{101contributor|Thomas Schmorleiz|developer}}