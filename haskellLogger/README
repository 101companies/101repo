== Intent ==

[[101feature:Logging|logging]] in [[Language:Haskell]] by means of the [[Writer Monad]]

== Languages ==

* [[Language:Haskell]]

== Technologies ==

* [[Technology:GHCi]]

== Features ==

* [[101feature:Company]]
* [[101feature:Total]]
* [[101feature:Cut]]
* [[101feature:Logging]]

== Motivation ==

We exercise [[101feature:Logging|Logging]] in [[Language:Haskell]] by making use of the [[Writer Monad]]. That is, during the process of [[101feature:Total|totaling]] and [[101feature:Cut|cutting]] [[101feature:Company|companies]] we log messages like intermediate results. In this implementation the logs are of type <syntaxhighlight lang=haskell" enclose="none">String</syntaxhighlight>, but they could be of any [[Monoid]] type.

== Illustration ==

=== Logging cutting ===

The functionality for cutting all company, department or employee salaries can be found in the ''Cut'' module (in [this!!Cut.hs]).

In the following we will show how cutting all department salaries is realized.

=== Logging department cutting ===

<syntaxhighlight lang="haskell" line>
cutLogDept :: Int -> Department -> Writer Log Department
cutLogDept n d@(Department name m dus eus) = do
    tell [replicate n '\t' ++ "Starting cutting Department \"" ++ name ++ "\", old Total = " ++ (show $ totalDept d)]
    cutManager <- cutLogEmployee (n + 1) m
    cutDus <- mapM (cutLogDept (n + 1)) dus
    cutEus <- mapM (cutLogEmployee (n + 1)) eus
    let cutD = Department name cutManager cutDus cutEus
    tell [replicate n '\t' ++ "Done cutting Department \"" ++ name ++ "\", new Total = " ++ (show $ totalDept cutD)]
    return cutD
</syntaxhighlight>

We log the start of the process of cutting a department by adding a message containing the department's name and the old total salary. We are making use of <syntaxhighlight lang=haskell" enclose="none">tell</syntaxhighlight> function, which is provided by the ''Control.Monad.Writer'' module, to add messages to the log.
To prettyPrint this log later on we indent all log lines using the given indent size <syntaxhighlight lang=haskell" enclose="none">n</syntaxhighlight>. We then cut the department manager passing the increased indent size in line 4. To cut all sub departments and employees we make use of the monadic map function <syntaxhighlight lang=haskell" enclose="none">mapM</syntaxhighlight> in lines 5 and 6. After that we log that department cutting is finished and what the new total salary is. Finally we return the value of the cut <syntaxhighlight lang=haskell" enclose="none">Department</syntaxhighlight>.

== Architecture ==

[this!!Total.hs] and [this!!Cut.hs] contain functionality to total and cut salaries while logging the process of doing so. [this!!Types.hs] holds the log type and a function for pretty printing logs. The algebraic datatype for companies can be found in [this!!Company.hs]. The ''Main'' module in [this!!Main.hs] collects test scenarios for totaling and cutting a sample company provided by [this!!SampleCompany.hs].

== Usage ==

The Haskell module ''Main'' has to be consulted with GHCi, and the
''main'' function has to be applied so that output for the test
scenarios is produced. The ''expected'' output is available through
the file ''baseline''. There is a ''Makefile'' with a target ''test''
for [[test automation]].
Use the taget ''clean'' to "reset" the project.

== Contributors ==

* {{101contributor|Thomas Schmorleiz|developer}}