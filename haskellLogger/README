== Intent ==

[[101feature:Logging|logging]] in [[Language:Haskell]] by means of the [[Writer Monad]]

== Languages ==

* [[Language:Haskell]]

== Technologies ==

* [[Technology:GHCi]]

== Features ==

* [[101feature:Company]]
* [[101feature:Total]]
* [[101feature:Cut]]
* [[101feature:Logging]]

== Motivation ==

We exercise [[101feature:Logging|Logging]] in [[Language:Haskell]] by making use of the [[Writer Monad]]. That is, during the process of [[101feature:Total|totaling]] and [[101feature:Cut|cutting]] [[101feature:Company|companies]] we log messages like intermediate results. In this implementation we choose that logs should be of type <syntaxhighlight lang="haskell" enclose="none">String</syntaxhighlight>, yet they could be of any [[Monoid]] type.

== Illustration ==

=== Logging cutting ===

The functionality for cutting all company, department or employee salaries can be found in the ''Cut'' module (in [this!!Cut.hs]).

In the following we will show how cutting all salaries in a given department is realized in the current implementation.

==== Logging department cutting ====

<syntaxhighlight lang="haskell" line>
cutLogDept :: Int -> Department -> Writer Log Department
cutLogDept n d@(Department name m dus eus) = do
    tell [replicate n '\t' ++ "Starting cutting Department \"" 
                           ++ name 
                           ++ "\", old Total = " 
                           ++ (show $ totalDept d)]
    cutManager <- cutLogEmployee (n + 1) m
    cutDus <- mapM (cutLogDept (n + 1)) dus
    cutEus <- mapM (cutLogEmployee (n + 1)) eus
    let cutD = Department name cutManager cutDus cutEus
    tell [replicate n '\t' ++ "Done cutting Department \"" 
                           ++ name 
                           ++ "\", new Total = " 
                           ++ (show $ totalDept cutD)]
    return cutD
</syntaxhighlight>

We log the start of the process of cutting a department by adding a message containing the department's name and the old total salary. We are making use of <syntaxhighlight lang="haskell" enclose="none">tell</syntaxhighlight> function, which is provided by the ''Control.Monad.Writer'' module, to add messages to the log.
To prettyPrint this log later on we indent all log lines using the given indent size <syntaxhighlight lang="haskell" enclose="none">n</syntaxhighlight>. We then cut the department manager passing the increased indent size in line 4. To cut all sub departments and employees we make use of the monadic map function <syntaxhighlight lang="haskell" enclose="none">mapM</syntaxhighlight> in lines 5 and 6. After that we log that department cutting is finished and what the new total salary is. Finally we return the value of the cut <syntaxhighlight lang="haskell" enclose="none">Department</syntaxhighlight>.

== Architecture ==

[this!!Total.hs] and [this!!Cut.hs] contain functionality to total and cut salaries while logging the process of doing so. [this!!Types.hs] holds the log type and a function for pretty printing logs. The algebraic datatype for companies can be found in [this!!Company.hs]. The ''Main'' module in [this!!Main.hs] collects test scenarios for totaling and cutting a sample company provided by [this!!SampleCompany.hs].

== Usage ==

* The Haskell module ''Main'' has to be loaded into GHCi. 
* The <syntaxhighlight lang="haskell" enclose="none">main</syntaxhighlight> function has to be applied.
* The output should be equal to the content of the file [this!!baseline].

One can also use the [this!Makefile] with a target ''test'' for test automation.

*Use the taget ''clean'' to "reset" the project.

== Contributors ==

* {{101contributor|Thomas Schmorleiz|developer}}