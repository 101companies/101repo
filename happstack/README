== Intent ==

[[Web programming]] with [[Technology:Happstack]] in [[Language:Haskell]] 

== Languages ==

* [[Language:Haskell]]
* [[Language:JavaScript]]
* [[Language:XHTML]]
* [[Language:CSS]]

== Technologies ==

* [[Technology:GHC]]
* [[Technology:Happstack]]
* [[Technology:Heist]]

== Features ==

* [[101feature:Company]]
* [[101feature:Total]]
* [[101feature:Cut]]
* [[101feature:Interaction]]
* [[101feature:Distribution]]
* [[101feature:Validation]]

== Motivation ==

This implementation provides a small client/server [[Web Application|web application]] written with the help of the [[Technology:Happstack]] [[:Category:Framework|framework]]. We exercice the use of [[Routing filter| routing filters]] to filter requests by action: A user can either view a specific part of a [[101feature:Company|company]], [[101feature:Cut|cut]] a specific part or save a company component after manipulation of primitive fields.
The company is stored in a client-sided [[Cookie|cookie]].
The part to be viewed, cut or saved is specified by making use if the [[Zipper|zipper]] concept. That is, the [[URL]] contains a company focus (see illustration section). 
We also demonstrate [[101feature:Validation|validation]]: When processing a save-request, sent by an HTML-form, the server applies various validators to eventuelly return error messages, which will be displayed to the user in the [[Browser|browser]]. As an response the client receives HTML-documents, composed by making use of the [[Technology:Heist]] HTML-templating engine.

== Illustration ==

In the following we will demonstate how a specific request is processed by the server.

=== Saving an Employee ===

'''Scenario:''' After requesting to view a manager the user manipulated the input fields and submits a request by clicking a save button.
The browser sends an HTTP-request together with a company-cookie to the server. The URL looks like this:

''<nowiki>http://localhost:8000/Employee/Save/ManagerFocus%20[0]/?Name=Erik&Address=Utrecht&Salary=1234.0</nowiki>''

==== Routing filter ====

The ''Main'' module (in [this!!Main.hs]) contains:

<syntaxhighlight lang="haskell" line>
main = simpleHTTP nullConf $ 
  msum [ path $ \v -> path $ \a -> path $ 
           \f -> mainPart a v f
       , serveDirectory EnableBrowsing [] "static"]   
</syntaxhighlight>

We set up a simple HTTP server, configured with a default configuration. We specify serveral possible server behaviours (values of <syntaxhighlight lang="haskell" enclose="none">ServerPartT</syntaxhighlight>) in a list, which we then apply to the <syntaxhighlight lang="haskell" enclose="none">MonadPlus</syntaxhighlight>-function <syntaxhighlight lang="haskell" enclose="none">msum</syntaxhighlight>. This function tries to run each server until one serverstart succeeds.

The first list element uses Happstack's <syntaxhighlight lang="haskell" enclose="none">path</syntaxhighlight> function in to extract:

* The view (here <syntaxhighlight lang="haskell" enclose="none">Employee</syntaxhighlight>)
* The action (here <syntaxhighlight lang="haskell" enclose="none">Save</syntaxhighlight>)
* The focus (here <syntaxhighlight lang="haskell" enclose="none">ManagerFocus [0]</syntaxhighlight>)
In case the extraction fails the server falls back to being a file server in line 2.
In case extraction succeeds <syntaxhighlight lang="haskell" enclose="none">mainPart</syntaxhighlight> is called passing the action, the view and the focus. This function is defined in ''Serverparts'', provided by [this!!Serverparts.hs]

<syntaxhighlight lang="haskell">
mainPart :: Action -> View -> Focus -> ServerPartT IO Response
mainPart View = viewPart
mainPart Cut  = cutPart
mainPart Save = savePart   
</syntaxhighlight>

In this case <syntaxhighlight lang="haskell" enclose="none">mainPart</syntaxhighlight> matches on  <syntaxhighlight lang="haskell" enclose="none">Save</syntaxhighlight> and calls 
<syntaxhighlight lang="haskell" enclose="none">savePart</syntaxhighlight> passing the view and the focus:

==== Saving ====

<syntaxhighlight lang="haskell" line>
savePart :: View -> Focus -> ServerPartT IO Response
savePart v f = do
  s <- save
  case s of
    (Left errs) -> do
      c <- readCCookie
      displayPart v f c errs
    (Right newc) -> displayPart v f newc []       
    where
      save = case v of
        CompanyV  -> saveCompany f
        DeptV     -> saveDepartment f
        EmployeeV -> saveEmployee f 
</syntaxhighlight>

The function starts by calling a save function, which is choosen based on the given <syntaxhighlight lang="haskell" enclose="none">View</syntaxhighlight> value. The <syntaxhighlight lang="haskell" enclose="none">save</syntaxhighlight>-functions, which are all of type <syntaxhighlight lang="haskell" enclose="none">Focus -> ServerPartT IO (Either [(ENames,String)] Company)</syntaxhighlight> either return a list of error information or the new company. In case of an error <syntaxhighlight lang="haskell" enclose="none">savePart</syntaxhighlight> calls <syntaxhighlight lang="haskell" enclose="none">displayPart</syntaxhighlight> in line 7 passing the old company (read from the cookie) and the errors. In case of success the new company and an empty list of errors is passed to <syntaxhighlight lang="haskell" enclose="none">displayPart</syntaxhighlight> in line 8. 

The ''Save'' module in [this!!Save.hs] holds the <syntaxhighlight lang="haskell" enclose="none">save</syntaxhighlight>-functions, in this case  <syntaxhighlight lang="haskell" enclose="none">saveEmployee</syntaxhighlight> is called:

<syntaxhighlight lang="haskell" line>
saveEmployee :: Focus -> ServerPartT IO (Either [(ENames,String)] Company)
saveEmployee f = do
  c <- readCCookie
  name <- look "Name"
  address <- look "Address"
  salary <- lookRead "Salary"
  let newe = Employee name address salary
  let ev = validateEmployee c f newe
  case ev of
    (Just errs)
        -> return $ Left errs
    Nothing
        -> do
            let newc = writeEM f c newe
            addCookie Session (mkCookie "company" (show newc))
            return $ Right newc
</syntaxhighlight>

<syntaxhighlight lang="haskell" enclose="none">saveEmployee</syntaxhighlight> reads the company from a cookie and extracts the request parameters from the URL in lines 3-6. <syntaxhighlight lang="haskell" enclose="none">lookRead</syntaxhighlight> also reads to a <syntaxhighlight lang="haskell" enclose="none">Double</syntaxhighlight> value. Then the new <syntaxhighlight lang="haskell" enclose="none">Employee</syntaxhighlight> value is composed using the contructor. In line 8 this employee is then passed to the validation function <syntaxhighlight lang="haskell" enclose="none">validateEmployee</syntaxhighlight> of type <syntaxhighlight lang="haskell" enclose="none">Validations Employee</syntaxhighlight>, which is a type alias for <syntaxhighlight lang="haskell" enclose="none">Company -> Focus -> a -> Maybe [(ENames,String)]</syntaxhighlight>. If the validation succeeds, <syntaxhighlight lang="haskell" enclose="none">validateEmployee</syntaxhighlight> returns <syntaxhighlight lang="haskell" enclose="none">Nothing</syntaxhighlight>. In this case the employee is replaced within the company, which is then re-stored in the cookie and returned by the function (lines 14-16). Otherwise <syntaxhighlight lang="haskell" enclose="none">validateEmployee</syntaxhighlight> returns error information, which are then also returned by <syntaxhighlight lang="haskell" enclose="none">saveEmployee</syntaxhighlight>.

==== Validation ====

The validation functionality can be found in the ''Validators'' module:

<syntaxhighlight lang="haskell">
validateEmployee :: Validations Employee
validateEmployee c f (Employee n a s) = if null vs 
                            then Nothing
                            else Just $ concat vs 
                              where 
                                vs = catMaybes [validateNA c f (n,a), validateSalary c f s]
</syntaxhighlight>

<syntaxhighlight lang="haskell" enclose="none">validateEmployee</syntaxhighlight> composes two validations (see [this!!Validators.hs] for details):

* <syntaxhighlight lang="haskell" enclose="none">validateNA</syntaxhighlight> checks whether the employee's name/address pair is unique in the company <syntaxhighlight lang="haskell" enclose="none">c</syntaxhighlight>.
* <syntaxhighlight lang="haskell" enclose="none">validateSalary</syntaxhighlight> checks two things regaring the employee's salary:
** Whether by changing the salary the employee's department-manager still receives the highest salary within the department.
** Whether the salary has a postive value.

In case both validations return <syntaxhighlight lang="haskell" enclose="none">Nothing</syntaxhighlight>, <syntaxhighlight lang="haskell" enclose="none">validateEmployee</syntaxhighlight> returns <syntaxhighlight lang="haskell" enclose="none">Nothing</syntaxhighlight>. Otherwise it returns the list of all error messages.

==== Binding and Responding ====

In our case the user might have tried to assign an invalid salary and an invalid name/address pair to the manager in question. Validation therefore would return error information. 
<syntaxhighlight lang="haskell" enclose="none">savePart</syntaxhighlight> would call <syntaxhighlight lang="haskell" enclose="none">displayPart</syntaxhighlight> passing the old company and the error messages:

<syntaxhighlight lang="haskell" line>
displayPart :: View -> Focus -> Company -> [(ENames,String)] -> ServerPart Response
displayPart v f c errs = do 
      td <- newTemplateDirectory' tDir (eNamesBinder errs $ binder f c $ emptyTemplateState tDir)
      render td (B.pack tname)
          where
            binder = case v of
              CompanyV  -> companyBinder
              DeptV     -> departmentBinder
              EmployeeV -> employeeBinder
                where
            tname = case v of
              CompanyV  -> "company"
              DeptV     -> "department"
              EmployeeV -> "employee"
</syntaxhighlight>

Based on the view <syntaxhighlight lang="haskell" enclose="none">displayPart</syntaxhighlight> decides which template and which binder to use in lines 6-14. The binder will bind all template variables to strings or small HTML fragments. After that <syntaxhighlight lang="haskell" enclose="none">eNamesBinder</syntaxhighlight> will bind the error messages to template varibales. Both binders can be found in [this!!Binder.hs]. 
They return a function of type <syntaxhighlight lang="haskell" enclose="none">Monad m => TemplateState m -> TemplateState m</syntaxhighlight>. That is, binders are state transformers for templates.

<syntaxhighlight lang="haskell" enclose="none">displayPart</syntaxhighlight> then renders the HTML document, which is sent to the client as the response in line 4.

== Architecture ==

[this!!Main.hs] holds the server, using various server parts in [this!!Serverparts]. The acutal save action is performed by functionality in [this!!Save.hs]. [this!!Binder.hs] contains functions to bind template varibales. The validators can be found in [this!!Validators.hs], using helper functions hosted by [this!!Utils.hs]. The algebraic datatype for companies can be found in [this!!Company], a sample company in [this!!SampleCompany.hs]. Functionality to total and cut is provided by [this!!Total.hs] and [this!!Cut.hs]. An API to companies based on the zipper concepts is hosted by [this!!API.hs]. Various types used by the server can be found in [this!!Types.hs]. [this!!static] contains the sytlesheet for the application and images. [this!!templates] contains the templates.

== Usage ==

* The Haskell module ''Main'' has to compiled with GHC. The executable has to be run. The Haskell module ''Main'' has to be run using ''runhaskell'' There is a ''Makefile'' with a target ''run'' to do this.
* Open [http://localhost:8000/Company/View/CompanyFocus] to demo, starting with the root view.

== Contributors ==

* {{101contributor|Thomas Schmorleiz|developer}}